'use strict';

var INUMBER = 'INUMBER';
var IOP1 = 'IOP1';
var IOP2 = 'IOP2';
var IOP3 = 'IOP3';
var IVAR = 'IVAR';
var IVARNAME = 'IVARNAME';
var IFUNCALL = 'IFUNCALL';
var IFUNDEF = 'IFUNDEF';
var IEXPR = 'IEXPR';
var IEXPREVAL = 'IEXPREVAL';
var IMEMBER = 'IMEMBER';
var IENDSTATEMENT = 'IENDSTATEMENT';
var IARRAY = 'IARRAY';

function Instruction(type, value) {
  this.type = type;
  this.value = (value !== undefined && value !== null) ? value : 0;
}

Instruction.prototype.toString = function () {
  switch (this.type) {
    case INUMBER:
    case IOP1:
    case IOP2:
    case IOP3:
    case IVAR:
    case IVARNAME:
    case IENDSTATEMENT:
      return this.value;
    case IFUNCALL:
      return 'CALL ' + this.value;
    case IFUNDEF:
      return 'DEF ' + this.value;
    case IARRAY:
      return 'ARRAY ' + this.value;
    case IMEMBER:
      return '.' + this.value;
    default:
      return 'Invalid Instruction';
  }
};

function unaryInstruction(value) {
  return new Instruction(IOP1, value);
}

function binaryInstruction(value) {
  return new Instruction(IOP2, value);
}

function ternaryInstruction(value) {
  return new Instruction(IOP3, value);
}

function simplify(tokens, unaryOps, binaryOps, ternaryOps, values) {
  var nstack = [];
  var newexpression = [];
  var n1, n2, n3;
  var f;
  for (var i = 0; i < tokens.length; i++) {
    var item = tokens[i];
    var type = item.type;
    if (type === INUMBER || type === IVARNAME) {
      if (Array.isArray(item.value)) {
        nstack.push.apply(nstack, simplify(item.value.map(function (x) {
          return new Instruction(INUMBER, x);
        }).concat(new Instruction(IARRAY, item.value.length)), unaryOps, binaryOps, ternaryOps, values));
      } else {
        nstack.push(item);
      }
    } else if (type === IVAR && values.hasOwnProperty(item.value)) {
      item = new Instruction(INUMBER, values[item.value]);
      nstack.push(item);
    } else if (type === IOP2 && nstack.length > 1) {
      n2 = nstack.pop();
      n1 = nstack.pop();
      f = binaryOps[item.value];
      item = new Instruction(INUMBER, f(n1.value, n2.value));
      nstack.push(item);
    } else if (type === IOP3 && nstack.length > 2) {
      n3 = nstack.pop();
      n2 = nstack.pop();
      n1 = nstack.pop();
      if (item.value === '?') {
        nstack.push(n1.value ? n2.value : n3.value);
      } else {
        f = ternaryOps[item.value];
        item = new Instruction(INUMBER, f(n1.value, n2.value, n3.value));
        nstack.push(item);
      }
    } else if (type === IOP1 && nstack.length > 0) {
      n1 = nstack.pop();
      f = unaryOps[item.value];
      item = new Instruction(INUMBER, f(n1.value));
      nstack.push(item);
    } else if (type === IEXPR) {
      while (nstack.length > 0) {
        newexpression.push(nstack.shift());
      }
      newexpression.push(new Instruction(IEXPR, simplify(item.value, unaryOps, binaryOps, ternaryOps, values)));
    } else if (type === IMEMBER && nstack.length > 0) {
      n1 = nstack.pop();
      nstack.push(new Instruction(INUMBER, n1.value[item.value]));
    } /* else if (type === IARRAY && nstack.length >= item.value) {
      var length = item.value;
      while (length-- > 0) {
        newexpression.push(nstack.pop());
      }
      newexpression.push(new Instruction(IARRAY, item.value));
    } */ else {
      while (nstack.length > 0) {
        newexpression.push(nstack.shift());
      }
      newexpression.push(item);
    }
  }
  while (nstack.length > 0) {
    newexpression.push(nstack.shift());
  }
  return newexpression;
}

function substitute(tokens, variable, expr) {
  var newexpression = [];
  for (var i = 0; i < tokens.length; i++) {
    var item = tokens[i];
    var type = item.type;
    if (type === IVAR && item.value === variable) {
      for (var j = 0; j < expr.tokens.length; j++) {
        var expritem = expr.tokens[j];
        var replitem;
        if (expritem.type === IOP1) {
          replitem = unaryInstruction(expritem.value);
        } else if (expritem.type === IOP2) {
          replitem = binaryInstruction(expritem.value);
        } else if (expritem.type === IOP3) {
          replitem = ternaryInstruction(expritem.value);
        } else {
          replitem = new Instruction(expritem.type, expritem.value);
        }
        newexpression.push(replitem);
      }
    } else if (type === IEXPR) {
      newexpression.push(new Instruction(IEXPR, substitute(item.value, variable, expr)));
    } else {
      newexpression.push(item);
    }
  }
  return newexpression;
}

function evaluate(tokens, expr, values) {
  var nstack = [];
  var n1, n2, n3;
  var f, args, argCount;

  if (isExpressionEvaluator(tokens)) {
    return resolveExpression(tokens, values);
  }

  var numTokens = tokens.length;

  for (var i = 0; i < numTokens; i++) {
    var item = tokens[i];
    var type = item.type;
    if (type === INUMBER || type === IVARNAME) {
      nstack.push(item.value);
    } else if (type === IOP2) {
      n2 = nstack.pop();
      n1 = nstack.pop();
      if (item.value === 'and') {
        nstack.push(n1 ? !!evaluate(n2, expr, values) : false);
      } else if (item.value === 'or') {
        nstack.push(n1 ? true : !!evaluate(n2, expr, values));
      } else if (item.value === '=') {
        f = expr.binaryOps[item.value];
        nstack.push(f(n1, evaluate(n2, expr, values), values));
      } else {
        f = expr.binaryOps[item.value];
        nstack.push(f(resolveExpression(n1, values), resolveExpression(n2, values)));
      }
    } else if (type === IOP3) {
      n3 = nstack.pop();
      n2 = nstack.pop();
      n1 = nstack.pop();
      if (item.value === '?') {
        nstack.push(evaluate(n1 ? n2 : n3, expr, values));
      } else {
        f = expr.ternaryOps[item.value];
        nstack.push(f(resolveExpression(n1, values), resolveExpression(n2, values), resolveExpression(n3, values)));
      }
    } else if (type === IVAR) {
      if (item.value in expr.functions) {
        nstack.push(expr.functions[item.value]);
      } else if (item.value in expr.unaryOps && expr.parser.isOperatorEnabled(item.value)) {
        nstack.push(expr.unaryOps[item.value]);
      } else {
        var v = values[item.value];
        if (v !== undefined) {
          nstack.push(v);
        } else {
          throw new Error('undefined variable: ' + item.value);
        }
      }
    } else if (type === IOP1) {
      n1 = nstack.pop();
      f = expr.unaryOps[item.value];
      nstack.push(f(resolveExpression(n1, values)));
    } else if (type === IFUNCALL) {
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(resolveExpression(nstack.pop(), values));
      }
      f = nstack.pop();
      if (f.apply && f.call) {
        nstack.push(f.apply(undefined, args));
      } else {
        throw new Error(f + ' is not a function');
      }
    } else if (type === IFUNDEF) {
      // Create closure to keep references to arguments and expression
      nstack.push((function () {
        var n2 = nstack.pop();
        var args = [];
        var argCount = item.value;
        while (argCount-- > 0) {
          args.unshift(nstack.pop());
        }
        var n1 = nstack.pop();
        var f = function () {
          var scope = Object.assign({}, values);
          for (var i = 0, len = args.length; i < len; i++) {
            scope[args[i]] = arguments[i];
          }
          return evaluate(n2, expr, scope);
        };
        // f.name = n1
        Object.defineProperty(f, 'name', {
          value: n1,
          writable: false
        });
        values[n1] = f;
        return f;
      })());
    } else if (type === IEXPR) {
      nstack.push(createExpressionEvaluator(item, expr));
    } else if (type === IEXPREVAL) {
      nstack.push(item);
    } else if (type === IMEMBER) {
      n1 = nstack.pop();
      nstack.push(n1[item.value]);
    } else if (type === IENDSTATEMENT) {
      nstack.pop();
    } else if (type === IARRAY) {
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(nstack.pop());
      }
      nstack.push(args);
    } else {
      throw new Error('invalid Expression');
    }
  }
  if (nstack.length > 1) {
    throw new Error('invalid Expression (parity)');
  }
  // Explicitly return zero to avoid test issues caused by -0
  return nstack[0] === 0 ? 0 : resolveExpression(nstack[0], values);
}

function createExpressionEvaluator(token, expr, values) {
  if (isExpressionEvaluator(token)) return token;
  return {
    type: IEXPREVAL,
    value: function (scope) {
      return evaluate(token.value, expr, scope);
    }
  };
}

function isExpressionEvaluator(n) {
  return n && n.type === IEXPREVAL;
}

function resolveExpression(n, values) {
  return isExpressionEvaluator(n) ? n.value(values) : n;
}

function expressionToString(tokens, toJS) {
  var nstack = [];
  var n1, n2, n3;
  var f, args, argCount;
  for (var i = 0; i < tokens.length; i++) {
    var item = tokens[i];
    var type = item.type;
    if (type === INUMBER) {
      if (typeof item.value === 'number' && item.value < 0) {
        nstack.push('(' + item.value + ')');
      } else if (Array.isArray(item.value)) {
        nstack.push('[' + item.value.map(escapeValue).join(', ') + ']');
      } else {
        nstack.push(escapeValue(item.value));
      }
    } else if (type === IOP2) {
      n2 = nstack.pop();
      n1 = nstack.pop();
      f = item.value;
      if (toJS) {
        if (f === '^') {
          nstack.push('Math.pow(' + n1 + ', ' + n2 + ')');
        } else if (f === 'and') {
          nstack.push('(!!' + n1 + ' && !!' + n2 + ')');
        } else if (f === 'or') {
          nstack.push('(!!' + n1 + ' || !!' + n2 + ')');
        } else if (f === '||') {
          nstack.push('(function(a,b){ return Array.isArray(a) && Array.isArray(b) ? a.concat(b) : String(a) + String(b); }((' + n1 + '),(' + n2 + ')))');
        } else if (f === '==') {
          nstack.push('(' + n1 + ' === ' + n2 + ')');
        } else if (f === '!=') {
          nstack.push('(' + n1 + ' !== ' + n2 + ')');
        } else if (f === '[') {
          nstack.push(n1 + '[(' + n2 + ') | 0]');
        } else {
          nstack.push('(' + n1 + ' ' + f + ' ' + n2 + ')');
        }
      } else {
        if (f === '[') {
          nstack.push(n1 + '[' + n2 + ']');
        } else {
          nstack.push('(' + n1 + ' ' + f + ' ' + n2 + ')');
        }
      }
    } else if (type === IOP3) {
      n3 = nstack.pop();
      n2 = nstack.pop();
      n1 = nstack.pop();
      f = item.value;
      if (f === '?') {
        nstack.push('(' + n1 + ' ? ' + n2 + ' : ' + n3 + ')');
      } else {
        throw new Error('invalid Expression');
      }
    } else if (type === IVAR || type === IVARNAME) {
      nstack.push(item.value);
    } else if (type === IOP1) {
      n1 = nstack.pop();
      f = item.value;
      if (f === '-' || f === '+') {
        nstack.push('(' + f + n1 + ')');
      } else if (toJS) {
        if (f === 'not') {
          nstack.push('(' + '!' + n1 + ')');
        } else if (f === '!') {
          nstack.push('fac(' + n1 + ')');
        } else {
          nstack.push(f + '(' + n1 + ')');
        }
      } else if (f === '!') {
        nstack.push('(' + n1 + '!)');
      } else {
        nstack.push('(' + f + ' ' + n1 + ')');
      }
    } else if (type === IFUNCALL) {
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(nstack.pop());
      }
      f = nstack.pop();
      nstack.push(f + '(' + args.join(', ') + ')');
    } else if (type === IFUNDEF) {
      n2 = nstack.pop();
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(nstack.pop());
      }
      n1 = nstack.pop();
      if (toJS) {
        nstack.push('(' + n1 + ' = function(' + args.join(', ') + ') { return ' + n2 + ' })');
      } else {
        nstack.push('(' + n1 + '(' + args.join(', ') + ') = ' + n2 + ')');
      }
    } else if (type === IMEMBER) {
      n1 = nstack.pop();
      nstack.push(n1 + '.' + item.value);
    } else if (type === IARRAY) {
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(nstack.pop());
      }
      nstack.push('[' + args.join(', ') + ']');
    } else if (type === IEXPR) {
      nstack.push('(' + expressionToString(item.value, toJS) + ')');
    } else if (type === IENDSTATEMENT) ; else {
      throw new Error('invalid Expression');
    }
  }
  if (nstack.length > 1) {
    if (toJS) {
      nstack = [ nstack.join(',') ];
    } else {
      nstack = [ nstack.join(';') ];
    }
  }
  return String(nstack[0]);
}

function escapeValue(v) {
  if (typeof v === 'string') {
    return JSON.stringify(v).replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
  }
  return v;
}

function contains(array, obj) {
  for (var i = 0; i < array.length; i++) {
    if (array[i] === obj) {
      return true;
    }
  }
  return false;
}

function getSymbols(tokens, symbols, options) {
  options = options || {};
  var withMembers = !!options.withMembers;
  var prevVar = null;

  for (var i = 0; i < tokens.length; i++) {
    var item = tokens[i];
    if (item.type === IVAR || item.type === IVARNAME) {
      if (!withMembers && !contains(symbols, item.value)) {
        symbols.push(item.value);
      } else if (prevVar !== null) {
        if (!contains(symbols, prevVar)) {
          symbols.push(prevVar);
        }
        prevVar = item.value;
      } else {
        prevVar = item.value;
      }
    } else if (item.type === IMEMBER && withMembers && prevVar !== null) {
      prevVar += '.' + item.value;
    } else if (item.type === IEXPR) {
      getSymbols(item.value, symbols, options);
    } else if (prevVar !== null) {
      if (!contains(symbols, prevVar)) {
        symbols.push(prevVar);
      }
      prevVar = null;
    }
  }

  if (prevVar !== null && !contains(symbols, prevVar)) {
    symbols.push(prevVar);
  }
}

function Expression(tokens, parser) {
  this.tokens = tokens;
  this.parser = parser;
  this.unaryOps = parser.unaryOps;
  this.binaryOps = parser.binaryOps;
  this.ternaryOps = parser.ternaryOps;
  this.functions = parser.functions;
}

Expression.prototype.simplify = function (values) {
  values = values || {};
  return new Expression(simplify(this.tokens, this.unaryOps, this.binaryOps, this.ternaryOps, values), this.parser);
};

Expression.prototype.substitute = function (variable, expr) {
  if (!(expr instanceof Expression)) {
    expr = this.parser.parse(String(expr));
  }

  return new Expression(substitute(this.tokens, variable, expr), this.parser);
};

Expression.prototype.evaluate = function (values) {
  values = values || {};
  return evaluate(this.tokens, this, values);
};

Expression.prototype.toString = function () {
  return expressionToString(this.tokens, false);
};

Expression.prototype.symbols = function (options) {
  options = options || {};
  var vars = [];
  getSymbols(this.tokens, vars, options);
  return vars;
};

Expression.prototype.variables = function (options) {
  options = options || {};
  var vars = [];
  getSymbols(this.tokens, vars, options);
  var functions = this.functions;
  return vars.filter(function (name) {
    return !(name in functions);
  });
};

Expression.prototype.toJSFunction = function (param, variables) {
  var expr = this;
  var f = new Function(param, 'with(this.functions) with (this.ternaryOps) with (this.binaryOps) with (this.unaryOps) { return ' + expressionToString(this.simplify(variables).tokens, true) + '; }'); // eslint-disable-line no-new-func
  return function () {
    return f.apply(expr, arguments);
  };
};

var TEOF = 'TEOF';
var TOP = 'TOP';
var TNUMBER = 'TNUMBER';
var TSTRING = 'TSTRING';
var TPAREN = 'TPAREN';
var TBRACKET = 'TBRACKET';
var TCOMMA = 'TCOMMA';
var TNAME = 'TNAME';
var TSEMICOLON = 'TSEMICOLON';

function Token(type, value, index) {
  this.type = type;
  this.value = value;
  this.index = index;
}

Token.prototype.toString = function () {
  return this.type + ': ' + this.value;
};

function TokenStream(parser, expression) {
  this.pos = 0;
  this.current = null;
  this.unaryOps = parser.unaryOps;
  this.binaryOps = parser.binaryOps;
  this.ternaryOps = parser.ternaryOps;
  this.consts = parser.consts;
  this.expression = expression;
  this.savedPosition = 0;
  this.savedCurrent = null;
  this.options = parser.options;
  this.parser = parser;
}

TokenStream.prototype.newToken = function (type, value, pos) {
  return new Token(type, value, pos != null ? pos : this.pos);
};

TokenStream.prototype.save = function () {
  this.savedPosition = this.pos;
  this.savedCurrent = this.current;
};

TokenStream.prototype.restore = function () {
  this.pos = this.savedPosition;
  this.current = this.savedCurrent;
};

TokenStream.prototype.next = function () {
  if (this.pos >= this.expression.length) {
    return this.newToken(TEOF, 'EOF');
  }

  if (this.isWhitespace() || this.isComment()) {
    return this.next();
  } else if (this.isRadixInteger() ||
      this.isNumber() ||
      this.isOperator() ||
      this.isString() ||
      this.isParen() ||
      this.isBracket() ||
      this.isComma() ||
      this.isSemicolon() ||
      this.isNamedOp() ||
      this.isConst() ||
      this.isName()) {
    return this.current;
  } else {
    this.parseError('Unknown character "' + this.expression.charAt(this.pos) + '"');
  }
};

TokenStream.prototype.isString = function () {
  var r = false;
  var startPos = this.pos;
  var quote = this.expression.charAt(startPos);

  if (quote === '\'' || quote === '"') {
    var index = this.expression.indexOf(quote, startPos + 1);
    while (index >= 0 && this.pos < this.expression.length) {
      this.pos = index + 1;
      if (this.expression.charAt(index - 1) !== '\\') {
        var rawString = this.expression.substring(startPos + 1, index);
        this.current = this.newToken(TSTRING, this.unescape(rawString), startPos);
        r = true;
        break;
      }
      index = this.expression.indexOf(quote, index + 1);
    }
  }
  return r;
};

TokenStream.prototype.isParen = function () {
  var c = this.expression.charAt(this.pos);
  if (c === '(' || c === ')') {
    this.current = this.newToken(TPAREN, c);
    this.pos++;
    return true;
  }
  return false;
};

TokenStream.prototype.isBracket = function () {
  var c = this.expression.charAt(this.pos);
  if ((c === '[' || c === ']') && this.isOperatorEnabled('[')) {
    this.current = this.newToken(TBRACKET, c);
    this.pos++;
    return true;
  }
  return false;
};

TokenStream.prototype.isComma = function () {
  var c = this.expression.charAt(this.pos);
  if (c === ',') {
    this.current = this.newToken(TCOMMA, ',');
    this.pos++;
    return true;
  }
  return false;
};

TokenStream.prototype.isSemicolon = function () {
  var c = this.expression.charAt(this.pos);
  if (c === ';') {
    this.current = this.newToken(TSEMICOLON, ';');
    this.pos++;
    return true;
  }
  return false;
};

TokenStream.prototype.isConst = function () {
  var startPos = this.pos;
  var i = startPos;
  for (; i < this.expression.length; i++) {
    var c = this.expression.charAt(i);
    if (c.toUpperCase() === c.toLowerCase()) {
      if (i === this.pos || (c !== '_' && c !== '.' && (c < '0' || c > '9'))) {
        break;
      }
    }
  }
  if (i > startPos) {
    var str = this.expression.substring(startPos, i);
    if (str in this.consts) {
      this.current = this.newToken(TNUMBER, this.consts[str]);
      this.pos += str.length;
      return true;
    }
  }
  return false;
};

TokenStream.prototype.isNamedOp = function () {
  var startPos = this.pos;
  var i = startPos;
  for (; i < this.expression.length; i++) {
    var c = this.expression.charAt(i);
    if (c.toUpperCase() === c.toLowerCase()) {
      if (i === this.pos || (c !== '_' && (c < '0' || c > '9'))) {
        break;
      }
    }
  }
  if (i > startPos) {
    var str = this.expression.substring(startPos, i);
    if (this.isOperatorEnabled(str) && (str in this.binaryOps || str in this.unaryOps || str in this.ternaryOps)) {
      this.current = this.newToken(TOP, str);
      this.pos += str.length;
      return true;
    }
  }
  return false;
};

TokenStream.prototype.isName = function () {
  var startPos = this.pos;
  var i = startPos;
  var hasLetter = false;
  for (; i < this.expression.length; i++) {
    var c = this.expression.charAt(i);
    if (c.toUpperCase() === c.toLowerCase()) {
      if (i === this.pos && (c === '$' || c === '_')) {
        if (c === '_') {
          hasLetter = true;
        }
        continue;
      } else if (i === this.pos || !hasLetter || (c !== '_' && (c < '0' || c > '9'))) {
        break;
      }
    } else {
      hasLetter = true;
    }
  }
  if (hasLetter) {
    var str = this.expression.substring(startPos, i);
    this.current = this.newToken(TNAME, str);
    this.pos += str.length;
    return true;
  }
  return false;
};

TokenStream.prototype.isWhitespace = function () {
  var r = false;
  var c = this.expression.charAt(this.pos);
  while (c === ' ' || c === '\t' || c === '\n' || c === '\r') {
    r = true;
    this.pos++;
    if (this.pos >= this.expression.length) {
      break;
    }
    c = this.expression.charAt(this.pos);
  }
  return r;
};

var codePointPattern = /^[0-9a-f]{4}$/i;

TokenStream.prototype.unescape = function (v) {
  var index = v.indexOf('\\');
  if (index < 0) {
    return v;
  }

  var buffer = v.substring(0, index);
  while (index >= 0) {
    var c = v.charAt(++index);
    switch (c) {
      case '\'':
        buffer += '\'';
        break;
      case '"':
        buffer += '"';
        break;
      case '\\':
        buffer += '\\';
        break;
      case '/':
        buffer += '/';
        break;
      case 'b':
        buffer += '\b';
        break;
      case 'f':
        buffer += '\f';
        break;
      case 'n':
        buffer += '\n';
        break;
      case 'r':
        buffer += '\r';
        break;
      case 't':
        buffer += '\t';
        break;
      case 'u':
        // interpret the following 4 characters as the hex of the unicode code point
        var codePoint = v.substring(index + 1, index + 5);
        if (!codePointPattern.test(codePoint)) {
          this.parseError('Illegal escape sequence: \\u' + codePoint);
        }
        buffer += String.fromCharCode(parseInt(codePoint, 16));
        index += 4;
        break;
      default:
        throw this.parseError('Illegal escape sequence: "\\' + c + '"');
    }
    ++index;
    var backslash = v.indexOf('\\', index);
    buffer += v.substring(index, backslash < 0 ? v.length : backslash);
    index = backslash;
  }

  return buffer;
};

TokenStream.prototype.isComment = function () {
  var c = this.expression.charAt(this.pos);
  if (c === '/' && this.expression.charAt(this.pos + 1) === '*') {
    this.pos = this.expression.indexOf('*/', this.pos) + 2;
    if (this.pos === 1) {
      this.pos = this.expression.length;
    }
    return true;
  }
  return false;
};

TokenStream.prototype.isRadixInteger = function () {
  var pos = this.pos;

  if (pos >= this.expression.length - 2 || this.expression.charAt(pos) !== '0') {
    return false;
  }
  ++pos;

  var radix;
  var validDigit;
  if (this.expression.charAt(pos) === 'x') {
    radix = 16;
    validDigit = /^[0-9a-f]$/i;
    ++pos;
  } else if (this.expression.charAt(pos) === 'b') {
    radix = 2;
    validDigit = /^[01]$/i;
    ++pos;
  } else {
    return false;
  }

  var valid = false;
  var startPos = pos;

  while (pos < this.expression.length) {
    var c = this.expression.charAt(pos);
    if (validDigit.test(c)) {
      pos++;
      valid = true;
    } else {
      break;
    }
  }

  if (valid) {
    this.current = this.newToken(TNUMBER, parseInt(this.expression.substring(startPos, pos), radix));
    this.pos = pos;
  }
  return valid;
};

TokenStream.prototype.isNumber = function () {
  var valid = false;
  var pos = this.pos;
  var startPos = pos;
  var resetPos = pos;
  var foundDot = false;
  var foundDigits = false;
  var c;

  while (pos < this.expression.length) {
    c = this.expression.charAt(pos);
    if ((c >= '0' && c <= '9') || (!foundDot && c === '.')) {
      if (c === '.') {
        foundDot = true;
      } else {
        foundDigits = true;
      }
      pos++;
      valid = foundDigits;
    } else {
      break;
    }
  }

  if (valid) {
    resetPos = pos;
  }

  if (c === 'e' || c === 'E') {
    pos++;
    var acceptSign = true;
    var validExponent = false;
    while (pos < this.expression.length) {
      c = this.expression.charAt(pos);
      if (acceptSign && (c === '+' || c === '-')) {
        acceptSign = false;
      } else if (c >= '0' && c <= '9') {
        validExponent = true;
        acceptSign = false;
      } else {
        break;
      }
      pos++;
    }

    if (!validExponent) {
      pos = resetPos;
    }
  }

  if (valid) {
    this.current = this.newToken(TNUMBER, parseFloat(this.expression.substring(startPos, pos)));
    this.pos = pos;
  } else {
    this.pos = resetPos;
  }
  return valid;
};

TokenStream.prototype.isOperator = function () {
  var startPos = this.pos;
  var c = this.expression.charAt(this.pos);

  if (c === '+' || c === '-' || c === '*' || c === '/' || c === '%' || c === '^' || c === '?' || c === ':' || c === '.') {
    this.current = this.newToken(TOP, c);
  } else if (c === '∙' || c === '•') {
    this.current = this.newToken(TOP, '*');
  } else if (c === '>') {
    if (this.expression.charAt(this.pos + 1) === '=') {
      this.current = this.newToken(TOP, '>=');
      this.pos++;
    } else {
      this.current = this.newToken(TOP, '>');
    }
  } else if (c === '<') {
    if (this.expression.charAt(this.pos + 1) === '=') {
      this.current = this.newToken(TOP, '<=');
      this.pos++;
    } else {
      this.current = this.newToken(TOP, '<');
    }
  } else if (c === '|') {
    if (this.expression.charAt(this.pos + 1) === '|') {
      this.current = this.newToken(TOP, '||');
      this.pos++;
    } else {
      return false;
    }
  } else if (c === '=') {
    if (this.expression.charAt(this.pos + 1) === '=') {
      this.current = this.newToken(TOP, '==');
      this.pos++;
    } else {
      this.current = this.newToken(TOP, c);
    }
  } else if (c === '!') {
    if (this.expression.charAt(this.pos + 1) === '=') {
      this.current = this.newToken(TOP, '!=');
      this.pos++;
    } else {
      this.current = this.newToken(TOP, c);
    }
  } else {
    return false;
  }
  this.pos++;

  if (this.isOperatorEnabled(this.current.value)) {
    return true;
  } else {
    this.pos = startPos;
    return false;
  }
};

TokenStream.prototype.isOperatorEnabled = function (op) {
  return this.parser.isOperatorEnabled(op);
};

TokenStream.prototype.getCoordinates = function () {
  var line = 0;
  var column;
  var newline = -1;
  do {
    line++;
    column = this.pos - newline;
    newline = this.expression.indexOf('\n', newline + 1);
  } while (newline >= 0 && newline < this.pos);

  return {
    line: line,
    column: column
  };
};

TokenStream.prototype.parseError = function (msg) {
  var coords = this.getCoordinates();
  throw new Error('parse error [' + coords.line + ':' + coords.column + ']: ' + msg);
};

function ParserState(parser, tokenStream, options) {
  this.parser = parser;
  this.tokens = tokenStream;
  this.current = null;
  this.nextToken = null;
  this.next();
  this.savedCurrent = null;
  this.savedNextToken = null;
  this.allowMemberAccess = options.allowMemberAccess !== false;
}

ParserState.prototype.next = function () {
  this.current = this.nextToken;
  return (this.nextToken = this.tokens.next());
};

ParserState.prototype.tokenMatches = function (token, value) {
  if (typeof value === 'undefined') {
    return true;
  } else if (Array.isArray(value)) {
    return contains(value, token.value);
  } else if (typeof value === 'function') {
    return value(token);
  } else {
    return token.value === value;
  }
};

ParserState.prototype.save = function () {
  this.savedCurrent = this.current;
  this.savedNextToken = this.nextToken;
  this.tokens.save();
};

ParserState.prototype.restore = function () {
  this.tokens.restore();
  this.current = this.savedCurrent;
  this.nextToken = this.savedNextToken;
};

ParserState.prototype.accept = function (type, value) {
  if (this.nextToken.type === type && this.tokenMatches(this.nextToken, value)) {
    this.next();
    return true;
  }
  return false;
};

ParserState.prototype.expect = function (type, value) {
  if (!this.accept(type, value)) {
    var coords = this.tokens.getCoordinates();
    throw new Error('parse error [' + coords.line + ':' + coords.column + ']: Expected ' + (value || type));
  }
};

ParserState.prototype.parseAtom = function (instr) {
  var unaryOps = this.tokens.unaryOps;
  function isPrefixOperator(token) {
    return token.value in unaryOps;
  }

  if (this.accept(TNAME) || this.accept(TOP, isPrefixOperator)) {
    instr.push(new Instruction(IVAR, this.current.value));
  } else if (this.accept(TNUMBER)) {
    instr.push(new Instruction(INUMBER, this.current.value));
  } else if (this.accept(TSTRING)) {
    instr.push(new Instruction(INUMBER, this.current.value));
  } else if (this.accept(TPAREN, '(')) {
    this.parseExpression(instr);
    this.expect(TPAREN, ')');
  } else if (this.accept(TBRACKET, '[')) {
    if (this.accept(TBRACKET, ']')) {
      instr.push(new Instruction(IARRAY, 0));
    } else {
      var argCount = this.parseArrayList(instr);
      instr.push(new Instruction(IARRAY, argCount));
    }
  } else {
    throw new Error('unexpected ' + this.nextToken);
  }
};

ParserState.prototype.parseExpression = function (instr) {
  var exprInstr = [];
  if (this.parseUntilEndStatement(instr, exprInstr)) {
    return;
  }
  this.parseVariableAssignmentExpression(exprInstr);
  if (this.parseUntilEndStatement(instr, exprInstr)) {
    return;
  }
  this.pushExpression(instr, exprInstr);
};

ParserState.prototype.pushExpression = function (instr, exprInstr) {
  for (var i = 0, len = exprInstr.length; i < len; i++) {
    instr.push(exprInstr[i]);
  }
};

ParserState.prototype.parseUntilEndStatement = function (instr, exprInstr) {
  if (!this.accept(TSEMICOLON)) return false;
  if (this.nextToken && this.nextToken.type !== TEOF && !(this.nextToken.type === TPAREN && this.nextToken.value === ')')) {
    exprInstr.push(new Instruction(IENDSTATEMENT));
  }
  if (this.nextToken.type !== TEOF) {
    this.parseExpression(exprInstr);
  }
  instr.push(new Instruction(IEXPR, exprInstr));
  return true;
};

ParserState.prototype.parseArrayList = function (instr) {
  var argCount = 0;

  while (!this.accept(TBRACKET, ']')) {
    this.parseExpression(instr);
    ++argCount;
    while (this.accept(TCOMMA)) {
      this.parseExpression(instr);
      ++argCount;
    }
  }

  return argCount;
};

ParserState.prototype.parseVariableAssignmentExpression = function (instr) {
  this.parseConditionalExpression(instr);
  while (this.accept(TOP, '=')) {
    var varName = instr.pop();
    var varValue = [];
    var lastInstrIndex = instr.length - 1;
    if (varName.type === IFUNCALL) {
      if (!this.tokens.isOperatorEnabled('()=')) {
        throw new Error('function definition is not permitted');
      }
      for (var i = 0, len = varName.value + 1; i < len; i++) {
        var index = lastInstrIndex - i;
        if (instr[index].type === IVAR) {
          instr[index] = new Instruction(IVARNAME, instr[index].value);
        }
      }
      this.parseVariableAssignmentExpression(varValue);
      instr.push(new Instruction(IEXPR, varValue));
      instr.push(new Instruction(IFUNDEF, varName.value));
      continue;
    }
    if (varName.type !== IVAR && varName.type !== IMEMBER) {
      throw new Error('expected variable for assignment');
    }
    this.parseVariableAssignmentExpression(varValue);
    instr.push(new Instruction(IVARNAME, varName.value));
    instr.push(new Instruction(IEXPR, varValue));
    instr.push(binaryInstruction('='));
  }
};

ParserState.prototype.parseConditionalExpression = function (instr) {
  this.parseOrExpression(instr);
  while (this.accept(TOP, '?')) {
    var trueBranch = [];
    var falseBranch = [];
    this.parseConditionalExpression(trueBranch);
    this.expect(TOP, ':');
    this.parseConditionalExpression(falseBranch);
    instr.push(new Instruction(IEXPR, trueBranch));
    instr.push(new Instruction(IEXPR, falseBranch));
    instr.push(ternaryInstruction('?'));
  }
};

ParserState.prototype.parseOrExpression = function (instr) {
  this.parseAndExpression(instr);
  while (this.accept(TOP, 'or')) {
    var falseBranch = [];
    this.parseAndExpression(falseBranch);
    instr.push(new Instruction(IEXPR, falseBranch));
    instr.push(binaryInstruction('or'));
  }
};

ParserState.prototype.parseAndExpression = function (instr) {
  this.parseComparison(instr);
  while (this.accept(TOP, 'and')) {
    var trueBranch = [];
    this.parseComparison(trueBranch);
    instr.push(new Instruction(IEXPR, trueBranch));
    instr.push(binaryInstruction('and'));
  }
};

var COMPARISON_OPERATORS = ['==', '!=', '<', '<=', '>=', '>', 'in'];

ParserState.prototype.parseComparison = function (instr) {
  this.parseAddSub(instr);
  while (this.accept(TOP, COMPARISON_OPERATORS)) {
    var op = this.current;
    this.parseAddSub(instr);
    instr.push(binaryInstruction(op.value));
  }
};

var ADD_SUB_OPERATORS = ['+', '-', '||'];

ParserState.prototype.parseAddSub = function (instr) {
  this.parseTerm(instr);
  while (this.accept(TOP, ADD_SUB_OPERATORS)) {
    var op = this.current;
    this.parseTerm(instr);
    instr.push(binaryInstruction(op.value));
  }
};

var TERM_OPERATORS = ['*', '/', '%'];

ParserState.prototype.parseTerm = function (instr) {
  this.parseFactor(instr);
  while (this.accept(TOP, TERM_OPERATORS)) {
    var op = this.current;
    this.parseFactor(instr);
    instr.push(binaryInstruction(op.value));
  }
};

ParserState.prototype.parseFactor = function (instr) {
  var unaryOps = this.tokens.unaryOps;
  function isPrefixOperator(token) {
    return token.value in unaryOps;
  }

  this.save();
  if (this.accept(TOP, isPrefixOperator)) {
    if (this.current.value !== '-' && this.current.value !== '+') {
      if (this.nextToken.type === TPAREN && this.nextToken.value === '(') {
        this.restore();
        this.parseExponential(instr);
        return;
      } else if (this.nextToken.type === TSEMICOLON || this.nextToken.type === TCOMMA || this.nextToken.type === TEOF || (this.nextToken.type === TPAREN && this.nextToken.value === ')')) {
        this.restore();
        this.parseAtom(instr);
        return;
      }
    }

    var op = this.current;
    this.parseFactor(instr);
    instr.push(unaryInstruction(op.value));
  } else {
    this.parseExponential(instr);
  }
};

ParserState.prototype.parseExponential = function (instr) {
  this.parsePostfixExpression(instr);
  while (this.accept(TOP, '^')) {
    this.parseFactor(instr);
    instr.push(binaryInstruction('^'));
  }
};

ParserState.prototype.parsePostfixExpression = function (instr) {
  this.parseFunctionCall(instr);
  while (this.accept(TOP, '!')) {
    instr.push(unaryInstruction('!'));
  }
};

ParserState.prototype.parseFunctionCall = function (instr) {
  var unaryOps = this.tokens.unaryOps;
  function isPrefixOperator(token) {
    return token.value in unaryOps;
  }

  if (this.accept(TOP, isPrefixOperator)) {
    var op = this.current;
    this.parseAtom(instr);
    instr.push(unaryInstruction(op.value));
  } else {
    this.parseMemberExpression(instr);
    while (this.accept(TPAREN, '(')) {
      if (this.accept(TPAREN, ')')) {
        instr.push(new Instruction(IFUNCALL, 0));
      } else {
        var argCount = this.parseArgumentList(instr);
        instr.push(new Instruction(IFUNCALL, argCount));
      }
    }
  }
};

ParserState.prototype.parseArgumentList = function (instr) {
  var argCount = 0;

  while (!this.accept(TPAREN, ')')) {
    this.parseExpression(instr);
    ++argCount;
    while (this.accept(TCOMMA)) {
      this.parseExpression(instr);
      ++argCount;
    }
  }

  return argCount;
};

ParserState.prototype.parseMemberExpression = function (instr) {
  this.parseAtom(instr);
  while (this.accept(TOP, '.') || this.accept(TBRACKET, '[')) {
    var op = this.current;

    if (op.value === '.') {
      if (!this.allowMemberAccess) {
        throw new Error('unexpected ".", member access is not permitted');
      }

      this.expect(TNAME);
      instr.push(new Instruction(IMEMBER, this.current.value));
    } else if (op.value === '[') {
      if (!this.tokens.isOperatorEnabled('[')) {
        throw new Error('unexpected "[]", arrays are disabled');
      }

      this.parseExpression(instr);
      this.expect(TBRACKET, ']');
      instr.push(binaryInstruction('['));
    } else {
      throw new Error('unexpected symbol: ' + op.value);
    }
  }
};

function add(a, b) {
  return Number(a) + Number(b);
}

function sub(a, b) {
  return a - b;
}

function mul(a, b) {
  return a * b;
}

function div(a, b) {
  return a / b;
}

function mod(a, b) {
  return a % b;
}

function concat(a, b) {
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.concat(b);
  }
  return '' + a + b;
}

function equal(a, b) {
  return a === b;
}

function notEqual(a, b) {
  return a !== b;
}

function greaterThan(a, b) {
  return a > b;
}

function lessThan(a, b) {
  return a < b;
}

function greaterThanEqual(a, b) {
  return a >= b;
}

function lessThanEqual(a, b) {
  return a <= b;
}

function andOperator(a, b) {
  return Boolean(a && b);
}

function orOperator(a, b) {
  return Boolean(a || b);
}

function inOperator(a, b) {
  return contains(b, a);
}

function sinh(a) {
  return ((Math.exp(a) - Math.exp(-a)) / 2);
}

function cosh(a) {
  return ((Math.exp(a) + Math.exp(-a)) / 2);
}

function tanh(a) {
  if (a === Infinity) return 1;
  if (a === -Infinity) return -1;
  return (Math.exp(a) - Math.exp(-a)) / (Math.exp(a) + Math.exp(-a));
}

function asinh(a) {
  if (a === -Infinity) return a;
  return Math.log(a + Math.sqrt((a * a) + 1));
}

function acosh(a) {
  return Math.log(a + Math.sqrt((a * a) - 1));
}

function atanh(a) {
  return (Math.log((1 + a) / (1 - a)) / 2);
}

function log10(a) {
  return Math.log(a) * Math.LOG10E;
}

function neg(a) {
  return -a;
}

function not(a) {
  return !a;
}

function trunc(a) {
  return a < 0 ? Math.ceil(a) : Math.floor(a);
}

function random(a) {
  return Math.random() * (a || 1);
}

function factorial(a) { // a!
  return gamma(a + 1);
}

function isInteger(value) {
  return isFinite(value) && (value === Math.round(value));
}

var GAMMA_G = 4.7421875;
var GAMMA_P = [
  0.99999999999999709182,
  57.156235665862923517, -59.597960355475491248,
  14.136097974741747174, -0.49191381609762019978,
  0.33994649984811888699e-4,
  0.46523628927048575665e-4, -0.98374475304879564677e-4,
  0.15808870322491248884e-3, -0.21026444172410488319e-3,
  0.21743961811521264320e-3, -0.16431810653676389022e-3,
  0.84418223983852743293e-4, -0.26190838401581408670e-4,
  0.36899182659531622704e-5
];

// Gamma function from math.js
function gamma(n) {
  var t, x;

  if (isInteger(n)) {
    if (n <= 0) {
      return isFinite(n) ? Infinity : NaN;
    }

    if (n > 171) {
      return Infinity; // Will overflow
    }

    var value = n - 2;
    var res = n - 1;
    while (value > 1) {
      res *= value;
      value--;
    }

    if (res === 0) {
      res = 1; // 0! is per definition 1
    }

    return res;
  }

  if (n < 0.5) {
    return Math.PI / (Math.sin(Math.PI * n) * gamma(1 - n));
  }

  if (n >= 171.35) {
    return Infinity; // will overflow
  }

  if (n > 85.0) { // Extended Stirling Approx
    var twoN = n * n;
    var threeN = twoN * n;
    var fourN = threeN * n;
    var fiveN = fourN * n;
    return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
      (1 + (1 / (12 * n)) + (1 / (288 * twoN)) - (139 / (51840 * threeN)) -
      (571 / (2488320 * fourN)) + (163879 / (209018880 * fiveN)) +
      (5246819 / (75246796800 * fiveN * n)));
  }

  --n;
  x = GAMMA_P[0];
  for (var i = 1; i < GAMMA_P.length; ++i) {
    x += GAMMA_P[i] / (n + i);
  }

  t = n + GAMMA_G + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
}

function stringOrArrayLength(s) {
  if (Array.isArray(s)) {
    return s.length;
  }
  return String(s).length;
}

function hypot() {
  var sum = 0;
  var larg = 0;
  for (var i = 0; i < arguments.length; i++) {
    var arg = Math.abs(arguments[i]);
    var div;
    if (larg < arg) {
      div = larg / arg;
      sum = (sum * div * div) + 1;
      larg = arg;
    } else if (arg > 0) {
      div = arg / larg;
      sum += div * div;
    } else {
      sum += arg;
    }
  }
  return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
}

function condition(cond, yep, nope) {
  return cond ? yep : nope;
}

/**
* Decimal adjustment of a number.
* From @escopecz.
*
* @param {Number} value The number.
* @param {Integer} exp  The exponent (the 10 logarithm of the adjustment base).
* @return {Number} The adjusted value.
*/
function roundTo(value, exp) {
  // If the exp is undefined or zero...
  if (typeof exp === 'undefined' || +exp === 0) {
    return Math.round(value);
  }
  value = +value;
  exp = -(+exp);
  // If the value is not a number or the exp is not an integer...
  if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
    return NaN;
  }
  // Shift
  value = value.toString().split('e');
  value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
  // Shift back
  value = value.toString().split('e');
  return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
}

function setVar(name, value, variables) {
  if (variables) variables[name] = value;
  return value;
}

function arrayIndex(array, index) {
  return array[index | 0];
}

function max$1(array) {
  if (arguments.length === 1 && Array.isArray(array)) {
    return Math.max.apply(Math, array);
  } else {
    return Math.max.apply(Math, arguments);
  }
}

function min(array) {
  if (arguments.length === 1 && Array.isArray(array)) {
    return Math.min.apply(Math, array);
  } else {
    return Math.min.apply(Math, arguments);
  }
}

function arrayMap(f, a) {
  if (typeof f !== 'function') {
    throw new Error('First argument to map is not a function');
  }
  if (!Array.isArray(a)) {
    throw new Error('Second argument to map is not an array');
  }
  return a.map(function (x, i) {
    return f(x, i);
  });
}

function arrayFold(f, init, a) {
  if (typeof f !== 'function') {
    throw new Error('First argument to fold is not a function');
  }
  if (!Array.isArray(a)) {
    throw new Error('Second argument to fold is not an array');
  }
  return a.reduce(function (acc, x, i) {
    return f(acc, x, i);
  }, init);
}

function arrayFilter(f, a) {
  if (typeof f !== 'function') {
    throw new Error('First argument to filter is not a function');
  }
  if (!Array.isArray(a)) {
    throw new Error('Second argument to filter is not an array');
  }
  return a.filter(function (x, i) {
    return f(x, i);
  });
}

function stringOrArrayIndexOf(target, s) {
  if (!(Array.isArray(s) || typeof s === 'string')) {
    throw new Error('Second argument to indexOf is not a string or array');
  }

  return s.indexOf(target);
}

function arrayJoin(sep, a) {
  if (!Array.isArray(a)) {
    throw new Error('Second argument to join is not an array');
  }

  return a.join(sep);
}

function sign(x) {
  return ((x > 0) - (x < 0)) || +x;
}

var ONE_THIRD = 1/3;
function cbrt(x) {
  return x < 0 ? -Math.pow(-x, ONE_THIRD) : Math.pow(x, ONE_THIRD);
}

function expm1(x) {
  return Math.exp(x) - 1;
}

function log1p(x) {
  return Math.log(1 + x);
}

function log2(x) {
  return Math.log(x) / Math.LN2;
}

function Parser(options) {
  this.options = options || {};
  this.unaryOps = {
    sin: Math.sin,
    cos: Math.cos,
    tan: Math.tan,
    asin: Math.asin,
    acos: Math.acos,
    atan: Math.atan,
    sinh: Math.sinh || sinh,
    cosh: Math.cosh || cosh,
    tanh: Math.tanh || tanh,
    asinh: Math.asinh || asinh,
    acosh: Math.acosh || acosh,
    atanh: Math.atanh || atanh,
    sqrt: Math.sqrt,
    cbrt: Math.cbrt || cbrt,
    log: Math.log,
    log2: Math.log2 || log2,
    ln: Math.log,
    lg: Math.log10 || log10,
    log10: Math.log10 || log10,
    expm1: Math.expm1 || expm1,
    log1p: Math.log1p || log1p,
    abs: Math.abs,
    ceil: Math.ceil,
    floor: Math.floor,
    round: Math.round,
    trunc: Math.trunc || trunc,
    '-': neg,
    '+': Number,
    exp: Math.exp,
    not: not,
    length: stringOrArrayLength,
    '!': factorial,
    sign: Math.sign || sign
  };

  this.binaryOps = {
    '+': add,
    '-': sub,
    '*': mul,
    '/': div,
    '%': mod,
    '^': Math.pow,
    '||': concat,
    '==': equal,
    '!=': notEqual,
    '>': greaterThan,
    '<': lessThan,
    '>=': greaterThanEqual,
    '<=': lessThanEqual,
    and: andOperator,
    or: orOperator,
    'in': inOperator,
    '=': setVar,
    '[': arrayIndex
  };

  this.ternaryOps = {
    '?': condition
  };

  this.functions = {
    random: random,
    fac: factorial,
    min: min,
    max: max$1,
    hypot: Math.hypot || hypot,
    pyt: Math.hypot || hypot, // backward compat
    pow: Math.pow,
    atan2: Math.atan2,
    'if': condition,
    gamma: gamma,
    roundTo: roundTo,
    map: arrayMap,
    fold: arrayFold,
    filter: arrayFilter,
    indexOf: stringOrArrayIndexOf,
    join: arrayJoin
  };

  this.consts = {
    E: Math.E,
    PI: Math.PI,
    'true': true,
    'false': false
  };
}

Parser.prototype.parse = function (expr) {
  var instr = [];
  var parserState = new ParserState(
    this,
    new TokenStream(this, expr),
    { allowMemberAccess: this.options.allowMemberAccess }
  );

  parserState.parseExpression(instr);
  parserState.expect(TEOF, 'EOF');

  return new Expression(instr, this);
};

Parser.prototype.evaluate = function (expr, variables) {
  return this.parse(expr).evaluate(variables);
};

var sharedParser = new Parser();

Parser.parse = function (expr) {
  return sharedParser.parse(expr);
};

Parser.evaluate = function (expr, variables) {
  return sharedParser.parse(expr).evaluate(variables);
};

var optionNameMap = {
  '+': 'add',
  '-': 'subtract',
  '*': 'multiply',
  '/': 'divide',
  '%': 'remainder',
  '^': 'power',
  '!': 'factorial',
  '<': 'comparison',
  '>': 'comparison',
  '<=': 'comparison',
  '>=': 'comparison',
  '==': 'comparison',
  '!=': 'comparison',
  '||': 'concatenate',
  'and': 'logical',
  'or': 'logical',
  'not': 'logical',
  '?': 'conditional',
  ':': 'conditional',
  '=': 'assignment',
  '[': 'array',
  '()=': 'fndef'
};

function getOptionName(op) {
  return optionNameMap.hasOwnProperty(op) ? optionNameMap[op] : op;
}

Parser.prototype.isOperatorEnabled = function (op) {
  var optionName = getOptionName(op);
  var operators = this.options.operators || {};

  return !(optionName in operators) || !!operators[optionName];
};

// @ts-nocheck
var dist = {};
var ast = {};
var errors = {};
Object.defineProperty(errors, "__esModule", { value: true });
class ParseError extends SyntaxError {
    static fromCode(code, offset) {
        return new ParseError(MESSAGES[code], code, offset);
    }
    constructor(message, code, offset) {
        super(message);
        this.code = code;
        this.index = offset;
    }
}
errors.ParseError = ParseError;
const MESSAGES = {
    "eof-in-string": "Unclosed string",
    "eof-in-comment": "Unclosed comment",
    "eof-in-bracket": "Unclosed bracket",
    "unexpected-parenthesis": "Unexpected token",
    "unexpected-calc-token": "Unexpected token",
};
(function (exports) {
    function __export(m) {
        for (var p in m)
            if (!exports.hasOwnProperty(p))
                exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(errors);
}(ast));
var cssCalc = {};
var parser$1 = {};
var nodeImpl = {};
var stringifier = {};
Object.defineProperty(stringifier, "__esModule", { value: true });
function rawVal(node, name) {
    const r = node.raws[name];
    return r ? r.raw : `${node[name]}`;
}
function raw(node, name) {
    const r = node.raws[name];
    return r || "";
}
function wrapRaws(node, inner) {
    return `${raw(node, "before")}${inner}`;
}
function numWithUnit(node) {
    return wrapRaws(node, `${rawVal(node, "value")}${rawVal(node, "unit")}`);
}
let Stringifier$1 = class Stringifier {
    constructor(options) {
        this.options = Object.assign({
            autofix: false,
        }, options || {});
    }
    stringify(node) {
        return this[node.type](node);
    }
    Root(node) {
        let s = "";
        for (const c of node.nodes) {
            s += this.stringify(c);
        }
        s += raw(node, "after");
        return s;
    }
    Function(node) {
        let s = `${node.name}(`;
        for (const c of node.nodes) {
            s += this.stringify(c);
        }
        s += raw(node, "beforeClose");
        if (this.options.autofix || !node.unclosed) {
            s += ")";
        }
        return wrapRaws(node, s);
    }
    Parentheses(node) {
        let s = "(";
        for (const c of node.nodes) {
            s += this.stringify(c);
        }
        s += raw(node, "beforeClose");
        if (this.options.autofix || !node.unclosed) {
            s += ")";
        }
        return wrapRaws(node, s);
    }
    MathExpression(node) {
        let beforeLeft = "";
        let between = raw(node, "between");
        let beforeRight = "";
        let afterRight = "";
        if (this.options.autofix) {
            if (!between) {
                between = " ";
            }
            if (!node.right.raws.before) {
                beforeRight = " ";
            }
            if (node.left.type === "MathExpression") {
                if ((node.left.operator === "+" ||
                    node.left.operator === "-") &&
                    (node.operator === "*" || node.operator === "/")) {
                    beforeLeft += "(";
                    between = `)${between}`;
                }
            }
            if (node.right.type === "MathExpression") {
                if ((node.operator === "+" && node.right.operator === "-") ||
                    ((node.operator === "-" || node.operator === "*") &&
                        (node.right.operator === "+" ||
                            node.right.operator === "-")) ||
                    node.operator === "/") {
                    beforeRight += "(";
                    afterRight = `)${afterRight}`;
                }
            }
        }
        return wrapRaws(node, `${beforeLeft}${this.stringify(node.left)}${between}${node.operator}${beforeRight}${this.stringify(node.right)}${afterRight}`);
    }
    Number(node) {
        return wrapRaws(node, rawVal(node, "value"));
    }
    Punctuator(node) {
        return wrapRaws(node, node.value);
    }
    Word(node) {
        return wrapRaws(node, node.value);
    }
    String(node) {
        return wrapRaws(node, node.value);
    }
    Operator(node) {
        return wrapRaws(node, node.value);
    }
    Length(node) {
        return numWithUnit(node);
    }
    Angle(node) {
        return numWithUnit(node);
    }
    Time(node) {
        return numWithUnit(node);
    }
    Frequency(node) {
        return numWithUnit(node);
    }
    Resolution(node) {
        return numWithUnit(node);
    }
    Percentage(node) {
        return numWithUnit(node);
    }
    Flex(node) {
        return numWithUnit(node);
    }
    word(node) {
        return node.value;
    }
    punctuator(node) {
        return node.value;
    }
    operator(node) {
        return node.value;
    }
    whitespace(node) {
        return node.value;
    }
    comment(node) {
        return node.value;
    }
    string(node) {
        return node.value;
    }
    "inline-comment"(node) {
        return node.value;
    }
};
stringifier.Stringifier = Stringifier$1;
Object.defineProperty(nodeImpl, "__esModule", { value: true });
const stringifier_1$1 = stringifier;
let defaultStringifier = null;
class Node {
    constructor() {
        this.parent = null;
    }
    toString(stringifier) {
        if (typeof stringifier === "function") {
            return stringifier(this);
        }
        return (stringifier ||
            defaultStringifier ||
            (defaultStringifier = new stringifier_1$1.Stringifier())).stringify(this);
    }
    walk(type, callback) {
        const node = this;
        let result = undefined;
        const nodes = [...(node.nodes || []), node.left, node.right].filter(n => Boolean(n));
        const check = typeof type === "string"
            ? (n) => n.type === type
            : (n) => type.test(n.type);
        for (const child of nodes) {
            if (check(child)) {
                result = callback(child);
                if (result === false) {
                    break;
                }
            }
            if (child.walk) {
                result = child.walk(type, callback);
                if (result === false) {
                    break;
                }
            }
        }
        return result;
    }
}
class Container extends Node {
    push(...children) {
        for (const child of children) {
            if (child.type === "Root") {
                this.push(...child.nodes);
            }
            else {
                child.parent = this;
                this.nodes.push(child);
            }
        }
        return this;
    }
    unshift(...children) {
        for (const child of children.reverse()) {
            if (child.type === "Root") {
                this.unshift(...child.nodes);
            }
            else {
                child.parent = this;
                this.nodes.unshift(child);
            }
        }
        return this;
    }
    append(...children) {
        return this.push(...children);
    }
    prepend(...children) {
        return this.unshift(...children);
    }
    insertBefore(exist, add) {
        if (add.type === "Root") {
            const { nodes } = add;
            if (nodes.length === 1) {
                return this.insertBefore(exist, nodes[0]);
            }
            throw new Error("The given Root node is illegal.");
        }
        const existIndex = this.nodes.indexOf(exist);
        if (existIndex < 0) {
            throw new Error("The given node could not be found.");
        }
        add.parent = this;
        this.nodes.splice(existIndex, 0, add);
        return this;
    }
    insertAfter(exist, add) {
        if (add.type === "Root") {
            const { nodes } = add;
            if (nodes.length === 1) {
                return this.insertAfter(exist, nodes[0]);
            }
            throw new Error("The given Root node is illegal.");
        }
        const existIndex = this.nodes.indexOf(exist);
        if (existIndex < 0) {
            throw new Error("The given node could not be found.");
        }
        add.parent = this;
        this.nodes.splice(existIndex + 1, 0, add);
        return this;
    }
    removeAll() {
        for (const node of this.nodes) {
            node.parent = null;
        }
        this.nodes = [];
        return this;
    }
    removeChild(child) {
        const index = this.nodes.indexOf(child);
        this.nodes[index].parent = null;
        this.nodes.splice(index, 1);
        return this;
    }
    get first() {
        return this.nodes[0] || null;
    }
    get last() {
        return this.nodes[this.nodes.length - 1] || null;
    }
}
class NumberValue extends Node {
    constructor(value, before, source) {
        super();
        const num = parseFloat(value);
        this.type = "Number";
        this.value = num;
        this.raws = {
            before,
            value: {
                raw: value,
                value: num,
            },
        };
        this.source = source;
    }
}
nodeImpl.NumberValue = NumberValue;
class NumWithUnitValue extends Node {
    constructor(type, value, unit, before, source) {
        super();
        const num = parseFloat(value);
        this.type = type;
        this.value = num;
        this.unit = unit;
        this.raws = {
            before,
            value: {
                raw: value,
                value: num,
            },
        };
        this.source = source;
    }
}
class LengthValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Length", value, unit, before, source);
    }
}
nodeImpl.LengthValue = LengthValue;
class AngleValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Angle", value, unit, before, source);
    }
}
nodeImpl.AngleValue = AngleValue;
class TimeValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Time", value, unit, before, source);
    }
}
nodeImpl.TimeValue = TimeValue;
class FrequencyValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Frequency", value, unit, before, source);
    }
}
nodeImpl.FrequencyValue = FrequencyValue;
class ResolutionValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Resolution", value, unit, before, source);
    }
}
nodeImpl.ResolutionValue = ResolutionValue;
class PercentageValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Percentage", value, unit, before, source);
    }
}
nodeImpl.PercentageValue = PercentageValue;
class FlexValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Flex", value, unit, before, source);
    }
}
nodeImpl.FlexValue = FlexValue;
class TokenValue extends Node {
    constructor(type, value, before, source) {
        super();
        this.type = type;
        this.value = value;
        this.raws = {
            before,
        };
        this.source = source;
    }
}
class Word extends TokenValue {
    constructor(value, before, source) {
        super("Word", value, before, source);
    }
}
nodeImpl.Word = Word;
class StringNode extends TokenValue {
    constructor(value, before, source) {
        super("String", value, before, source);
    }
}
nodeImpl.StringNode = StringNode;
function defineAssessor(obj, name, setterProc) {
    const localName = Symbol(`${name}`);
    Object.defineProperties(obj, {
        [localName]: { writable: true, enumerable: false },
        [name]: {
            get() {
                return this[localName];
            },
            set(n) {
                const o = this[localName];
                this[localName] = setterProc(n, o);
            },
            enumerable: true,
        },
    });
}
class MathExpression extends Node {
    constructor(left, operator, right, before, source) {
        super();
        const ope = operator.value;
        const between = operator.raws.before;
        this.type = "MathExpression";
        const setterProc = (n, o) => {
            let e;
            if (n.type === "Root") {
                const { nodes } = n;
                if (nodes.length === 1) {
                    e = nodes[0];
                }
                else {
                    throw new Error("The given Root node is illegal.");
                }
            }
            else {
                e = n;
            }
            e.parent = this;
            if (o) {
                o.parent = null;
            }
            return e;
        };
        defineAssessor(this, "left", setterProc);
        this.left = left;
        this.operator = ope;
        defineAssessor(this, "right", setterProc);
        this.right = right;
        this.raws = { before, between };
        this.source = source;
    }
}
nodeImpl.MathExpression = MathExpression;
class FunctionNode extends Container {
    constructor(name, before, source) {
        super();
        this.type = "Function";
        this.name = name;
        this.nodes = [];
        this.raws = { before };
        this.source = source;
    }
}
nodeImpl.FunctionNode = FunctionNode;
class Parentheses extends Container {
    constructor(before, source) {
        super();
        this.type = "Parentheses";
        this.nodes = [];
        this.raws = { before };
        this.source = source;
    }
}
nodeImpl.Parentheses = Parentheses;
class Punctuator extends TokenValue {
    constructor(value, before, source) {
        super("Punctuator", value, before, source);
    }
}
nodeImpl.Punctuator = Punctuator;
class Root extends Container {
    constructor(source) {
        super();
        this.type = "Root";
        this.nodes = [];
        this.tokens = [];
        this.errors = [];
        this.raws = { after: "" };
        this.source = source;
    }
}
nodeImpl.Root = Root;
class Operator extends TokenValue {
    constructor(value, before, source) {
        super("Operator", value, before, source);
    }
}
nodeImpl.Operator = Operator;
var factory = {};
var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);
var unit = function (value) {
    var pos = 0;
    var length = value.length;
    var dotted = false;
    var sciPos = -1;
    var containsNumber = false;
    var code;
    while (pos < length) {
        code = value.charCodeAt(pos);
        if (code >= 48 && code <= 57) {
            containsNumber = true;
        }
        else if (code === exp || code === EXP) {
            if (sciPos > -1) {
                break;
            }
            sciPos = pos;
        }
        else if (code === dot) {
            if (dotted) {
                break;
            }
            dotted = true;
        }
        else if (code === plus || code === minus) {
            if (pos !== 0) {
                break;
            }
        }
        else {
            break;
        }
        pos += 1;
    }
    if (sciPos + 1 === pos)
        pos--;
    return containsNumber
        ? {
            number: value.slice(0, pos),
            unit: value.slice(pos)
        }
        : false;
};
Object.defineProperty(factory, "__esModule", { value: true });
const valueParserUnit = unit;
const Impl$1 = nodeImpl;
const LENGTH_UNITS = [
    "em",
    "ex",
    "ch",
    "rem",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "px",
    "mm",
    "cm",
    "in",
    "pt",
    "pc",
    "Q",
    "vm",
];
const ANGLE_UNITS = ["deg", "grad", "turn", "rad"];
const TIME_UNITS = ["s", "ms"];
const FREQUENCY_UNITS = ["Hz", "kHz"];
const RESOLUTION_UNITS = ["dpi", "dpcm", "dppm"];
const FLEX_UNITS = ["fr"];
const L_LENGTH_UNITS = LENGTH_UNITS.map(u => u.toLowerCase());
const L_ANGLE_UNITS = ANGLE_UNITS.map(u => u.toLowerCase());
const L_TIME_UNITS = TIME_UNITS.map(u => u.toLowerCase());
const L_FREQUENCY_UNITS = FREQUENCY_UNITS.map(u => u.toLowerCase());
const L_RESOLUTION_UNITS = RESOLUTION_UNITS.map(u => u.toLowerCase());
const L_FLEX_UNITS = FLEX_UNITS.map(u => u.toLowerCase());
function newPunctuator(token, before) {
    if (token.value === "," || token.value === ")") {
        return newTokenNode(Impl$1.Punctuator, token, token.value, before);
    }
    throw new Error(`illegal argument error "${token.value}"`);
}
factory.newPunctuator = newPunctuator;
function newOperator(token, before) {
    return newTokenNode(Impl$1.Operator, token, token.value, before);
}
factory.newOperator = newOperator;
function newString(token, before) {
    return newTokenNode(Impl$1.StringNode, token, token.value, before);
}
factory.newString = newString;
function newWordNode(token, before) {
    return newValueNode(token, before);
}
factory.newWordNode = newWordNode;
function newFunction(token, before, open) {
    return new Impl$1.FunctionNode(token.value, before, {
        start: token.source.start,
        end: open.source.end,
    });
}
factory.newFunction = newFunction;
function newParentheses(token, before) {
    return new Impl$1.Parentheses(before, {
        start: token.source.start,
        end: token.source.end,
    });
}
factory.newParentheses = newParentheses;
function newMathExpression(left, op, right) {
    const opNode = typeof op === "string"
        ? newTokenNode(Impl$1.Operator, { source: { start: { index: 0 }, end: { index: 0 } } }, op, " ")
        : op;
    const { before } = left.raws;
    left.raws.before = "";
    return new Impl$1.MathExpression(left, opNode, right, before, {
        start: left.source.start,
        operator: opNode.source,
        end: right.source.end,
    });
}
factory.newMathExpression = newMathExpression;
function newValueNode(token, before) {
    if (token.type === "word") {
        const parsedUnit = valueParserUnit(token.value);
        if (parsedUnit) {
            const n = newNumNode(parsedUnit, token, before);
            if (n) {
                return n;
            }
        }
    }
    return newTokenNode(Impl$1.Word, token, token.value, before);
}
function newNumNode(parsedUnit, token, before) {
    const { source } = token;
    if (!parsedUnit.unit) {
        return new Impl$1.NumberValue(parsedUnit.number, before, source);
    }
    const lunit = parsedUnit.unit.toLowerCase();
    function unitNode(WithUnitValue, unit) {
        const n = new WithUnitValue(parsedUnit.number, unit, before, source);
        if (unit !== parsedUnit.unit) {
            n.raws.unit = {
                raw: parsedUnit.unit,
                value: unit,
            };
        }
        return n;
    }
    let unitIndex;
    if ((unitIndex = L_LENGTH_UNITS.indexOf(lunit)) >= 0) {
        return unitNode(Impl$1.LengthValue, LENGTH_UNITS[unitIndex]);
    }
    if ((unitIndex = L_ANGLE_UNITS.indexOf(lunit)) >= 0) {
        return unitNode(Impl$1.AngleValue, ANGLE_UNITS[unitIndex]);
    }
    if ((unitIndex = L_TIME_UNITS.indexOf(lunit)) >= 0) {
        return unitNode(Impl$1.TimeValue, TIME_UNITS[unitIndex]);
    }
    if ((unitIndex = L_FREQUENCY_UNITS.indexOf(lunit)) >= 0) {
        return unitNode(Impl$1.FrequencyValue, FREQUENCY_UNITS[unitIndex]);
    }
    if ((unitIndex = L_RESOLUTION_UNITS.indexOf(lunit)) >= 0) {
        return unitNode(Impl$1.ResolutionValue, RESOLUTION_UNITS[unitIndex]);
    }
    if ((unitIndex = L_FLEX_UNITS.indexOf(lunit)) >= 0) {
        return unitNode(Impl$1.FlexValue, FLEX_UNITS[unitIndex]);
    }
    if (lunit === "%") {
        return unitNode(Impl$1.PercentageValue, "%");
    }
    return null;
}
function newTokenNode(TokenValue, token, value, before) {
    const { source } = token;
    return new TokenValue(value, before, source);
}
var calcNotation = {};
Object.defineProperty(calcNotation, "__esModule", { value: true });
const RE_CALC = /^(-(webkit|mox)-)?calc/iu;
const RE_MIN = /^(-(webkit|mox)-)?min/iu;
const RE_MAX = /^(-(webkit|mox)-)?max/iu;
const RE_CLAMP = /^(-(webkit|mox)-)?clamp/iu;
function isCalc(name) {
    return RE_CALC.test(name);
}
calcNotation.isCalc = isCalc;
function isMin(name) {
    return RE_MIN.test(name);
}
calcNotation.isMin = isMin;
function isMax(name) {
    return RE_MAX.test(name);
}
calcNotation.isMax = isMax;
function isClamp(name) {
    return RE_CLAMP.test(name);
}
calcNotation.isClamp = isClamp;
function isMathFunction(name) {
    return isCalc(name) || isClamp(name) || isMin(name) || isMax(name);
}
calcNotation.isMathFunction = isMathFunction;
var utils = {};
Object.defineProperty(utils, "__esModule", { value: true });
function isComma(node) {
    return node.type === "Punctuator" && node.value === ",";
}
utils.isComma = isComma;
function getFunctionArguments(fn) {
    const { nodes } = fn;
    const first = nodes[0];
    if (!first || isComma(first)) {
        return null;
    }
    const result = [first];
    const length = nodes.length;
    for (let index = 1; index < length; index++) {
        const comma = nodes[index++];
        if (!isComma(comma)) {
            return null;
        }
        const arg = nodes[index];
        if (!arg || isComma(arg)) {
            return null;
        }
        result.push(arg);
    }
    return result;
}
utils.getFunctionArguments = getFunctionArguments;
Object.defineProperty(parser$1, "__esModule", { value: true });
const AST$2 = ast;
const Impl = nodeImpl;
const factory_1$1 = factory;
const calc_notation_1$2 = calcNotation;
const utils_1$2 = utils;
const MAYBE_FUNCTION = /^([^-+0-9.]|-[^+0-9.])/u;
const PRECEDENCE = {
    "*": 3,
    "/": 3,
    "+": 2,
    "-": 2,
};
function srcLoc(node) {
    return node.source || { start: { index: 0 }, end: { index: 0 } };
}
function isExpression(node) {
    if (node && node.type !== "Punctuator" && node.type !== "Operator") {
        return node;
    }
    return null;
}
let Parser$1 = class Parser {
    constructor(tokenizer, _options) {
        this.tokenizer = tokenizer;
        this.root = new Impl.Root({
            start: {
                index: 0,
            },
            end: {
                index: 0,
            },
        });
        this.rescans = [];
        this.tokens = this.root.tokens;
        this.errors = this.root.errors;
    }
    parse() {
        let state = {
            container: this.root,
            fnName: "",
            post() {
            },
            eof() {
            },
        };
        while (state) {
            state = this.processExpressions(state);
        }
        const { tokens } = this;
        if (tokens.length > 0) {
            srcLoc(this.root).end.index =
                tokens[tokens.length - 1].source.end.index;
        }
        this.errors.unshift(...this.tokenizer.errors);
        this.errors.sort((e1, e2) => e1.index - e2.index);
        return this.root;
    }
    reportParseError(code, index = 0) {
        if (this.errors.find(e => e.code === code && e.index === index)) {
            return;
        }
        const error = AST$2.ParseError.fromCode(code, index);
        this.errors.push(error);
    }
    processExpressions(state) {
        let tokenSet;
        while ((tokenSet = this.scan())) {
            const { token } = tokenSet;
            switch (token.type) {
                case "word":
                    if (MAYBE_FUNCTION.test(token.value)) {
                        const next = this.scan();
                        if (next) {
                            if (!next.raws &&
                                next.token.type === "punctuator" &&
                                next.token.value === "(") {
                                return this.processFunction(token, tokenSet.raws, next.token, state);
                            }
                            this.back(next);
                        }
                    }
                    state.container.push(factory_1$1.newWordNode(token, tokenSet.raws));
                    break;
                case "string":
                    state.container.push(factory_1$1.newString(token, tokenSet.raws));
                    break;
                case "operator":
                    this.checkAndMergeMathExpr(state, PRECEDENCE[token.value]);
                    state.container.push(factory_1$1.newOperator(token, tokenSet.raws));
                    break;
                case "punctuator":
                    this.checkAndMergeMathExpr(state);
                    return this.processPunctuator(token, tokenSet.raws, state);
            }
        }
        this.postStack(state);
        state.eof();
        return null;
    }
    checkAndMergeMathExpr(state, currPrecedence) {
        const { container } = state;
        const { nodes } = container;
        if (nodes.length >= 3) {
            const bfOp = nodes[nodes.length - 2];
            if (bfOp.type === "Operator" && PRECEDENCE[bfOp.value]) {
                if (currPrecedence == null ||
                    currPrecedence <= PRECEDENCE[bfOp.value]) {
                    const math = this.mergeMathExpr(state);
                    if (math) {
                        container.push(math);
                    }
                }
            }
        }
    }
    processPunctuator(token, before, state) {
        const { container, parent } = state;
        if (token.value === "(") {
            const node = factory_1$1.newParentheses(token, before);
            container.push(node);
            return this.createNestedStateContainer(node, state.fnName, state);
        }
        this.postStack(state);
        if (token.value === ")") {
            if (parent) {
                state.post(token, before);
                return parent;
            }
            this.reportParseError("unexpected-parenthesis", token.source.start.index);
        }
        container.push(factory_1$1.newPunctuator(token, before));
        return state;
    }
    processFunction(token, before, open, state) {
        const node = factory_1$1.newFunction(token, before, open);
        state.container.push(node);
        return this.createNestedStateContainer(node, node.name, state);
    }
    createNestedStateContainer(node, fnName, state) {
        return {
            container: node,
            parent: state,
            fnName,
            post(close, beforeClose) {
                if (beforeClose) {
                    node.raws.beforeClose = beforeClose;
                }
                srcLoc(node).end = close.source.end;
            },
            eof: () => {
                node.unclosed = true;
                const last = this.tokens[this.tokens.length - 1];
                const lastChild = node.last;
                if (lastChild) {
                    srcLoc(node).end = srcLoc(lastChild).end;
                }
                this.reportParseError("eof-in-bracket", last.source.end.index);
                state.eof();
            },
        };
    }
    mergeMathExpr(state) {
        const { container: { nodes }, } = state;
        const right = nodes.pop();
        const op = nodes.pop();
        const left = nodes.pop() || null;
        const restore = () => {
            if (left) {
                nodes.push(left);
            }
            nodes.push(op, right);
        };
        const reportError = (node) => {
            if (calc_notation_1$2.isMathFunction(state.fnName)) {
                this.reportParseError("unexpected-calc-token", srcLoc(node).start.index);
            }
        };
        const rightExpr = isExpression(right);
        if (utils_1$2.isComma(op)) {
            if (!rightExpr) {
                reportError(right);
            }
            restore();
            return null;
        }
        if (!left) {
            reportError(isExpression(op) ? right : op);
            restore();
            return null;
        }
        const leftExpr = isExpression(left);
        if (!leftExpr) {
            reportError(isExpression(nodes[nodes.length - 1]) ? op : left);
            restore();
            return null;
        }
        if (op.type !== "Operator") {
            reportError(op);
            restore();
            return null;
        }
        if (!rightExpr) {
            reportError(right);
            restore();
            return null;
        }
        return factory_1$1.newMathExpression(leftExpr, op, rightExpr);
    }
    postStack(state) {
        const { container } = state;
        const { nodes } = container;
        while (nodes.length > 1) {
            const math = this.mergeMathExpr(state);
            if (math) {
                container.push(math);
            }
            else {
                return;
            }
        }
    }
    scan() {
        const re = this.rescans.shift();
        if (re) {
            return re;
        }
        let raws = "";
        let token = this.tokenizer.nextToken();
        while (token) {
            this.tokens.push(token);
            if (token.type === "whitespace" ||
                token.type === "comment" ||
                token.type === "inline-comment") {
                raws += token.value;
            }
            else {
                return {
                    token,
                    raws,
                };
            }
            token = this.tokenizer.nextToken();
        }
        if (raws) {
            this.root.raws.after = raws;
        }
        return null;
    }
    back(tokenset) {
        this.rescans.unshift(tokenset);
    }
};
parser$1.Parser = Parser$1;
var tokenizer = {};
var unicode = {};
(function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EOF = -1;
    exports.NULL = 0x00;
    exports.TAB = 0x09;
    exports.CR = 0x0d;
    exports.LF = 0x0a;
    exports.FF = 0x0c;
    exports.SPACE = 0x20;
    exports.DQUOTE = 0x22;
    exports.SQUOTE = 0x27;
    exports.LPAREN = 0x28;
    exports.RPAREN = 0x29;
    exports.STAR = 0x2a;
    exports.PLUS = 0x2b;
    exports.COMMA = 0x2c;
    exports.MINUS = 0x2d;
    exports.DOT = 0x2e;
    exports.SLASH = 0x2f;
    exports.LBRACKET = 0x5b;
    exports.BACKSLASH = 0x5c;
    exports.RBRACKET = 0x5d;
    exports.LBRACE = 0x7b;
    exports.RBRACE = 0x7d;
    function isWhitespace(cc) {
        return cc === exports.TAB || cc === exports.LF || cc === exports.FF || cc === exports.CR || cc === exports.SPACE;
    }
    exports.isWhitespace = isWhitespace;
    function isDigit(cc) {
        return cc >= 0x30 && cc <= 0x39;
    }
    exports.isDigit = isDigit;
    function isLetter(cc) {
        return ((cc >= 0x61 && cc <= 0x7a) ||
            (cc >= 0x41 && cc <= 0x5a));
    }
    exports.isLetter = isLetter;
}(unicode));
Object.defineProperty(tokenizer, "__esModule", { value: true });
const AST$1 = ast;
const unicode_1 = unicode;
function isPunctuator(cc) {
    return cc === unicode_1.LPAREN || cc === unicode_1.RPAREN || cc === unicode_1.COMMA;
}
function maybeNumber(cc) {
    return unicode_1.isDigit(cc) || cc === unicode_1.DOT;
}
function isQuotes(cc) {
    return cc === unicode_1.DQUOTE || cc === unicode_1.SQUOTE;
}
function getRightBracket(cc) {
    if (cc === unicode_1.LPAREN) {
        return unicode_1.RPAREN;
    }
    if (cc === unicode_1.LBRACE) {
        return unicode_1.RBRACE;
    }
    return unicode_1.RBRACKET;
}
let Tokenizer$1 = class Tokenizer {
    constructor(text, options) {
        this.lastCode = unicode_1.NULL;
        this.rescan = false;
        this.token = null;
        this.lastTokenType = null;
        this.errors = [];
        this.text = text;
        this.offset = -1;
        this.state = "SCAN";
        this.nextTokenOffset = 0;
        this.options = Object.assign({
            allowInlineCommnets: true,
        }, options || {});
    }
    nextToken() {
        while (this.token == null) {
            const cc = this.scan();
            this.state = this[this.state](cc) || "SCAN";
            if (cc === unicode_1.EOF && !this.rescan) {
                break;
            }
        }
        const { token } = this;
        this.token = null;
        return token;
    }
    scan() {
        if (this.rescan) {
            this.rescan = false;
            return this.lastCode;
        }
        return this.next();
    }
    next() {
        if (this.offset < this.text.length) {
            this.offset++;
        }
        if (this.offset >= this.text.length) {
            return (this.lastCode = unicode_1.EOF);
        }
        return (this.lastCode = this.text.charCodeAt(this.offset));
    }
    back() {
        this.rescan = true;
    }
    reportParseError(code) {
        const error = AST$1.ParseError.fromCode(code, this.offset);
        this.errors.push(error);
    }
    getCode(indexOffset = 0) {
        return this.text.charCodeAt(this.nextTokenOffset + indexOffset);
    }
    commitToken(type, indexOffset = 0) {
        const start = this.nextTokenOffset;
        const offset = this.offset + indexOffset + 1;
        const value = this.text.slice(start, offset);
        this.token = {
            type,
            value,
            source: {
                start: {
                    index: start,
                },
                end: {
                    index: offset,
                },
            },
        };
        this.nextTokenOffset = offset;
        this.lastTokenType = type;
    }
    SCAN(cc) {
        if (unicode_1.isWhitespace(cc)) {
            return "WHITESPACE";
        }
        if (cc === unicode_1.DQUOTE) {
            return "DQUOTE";
        }
        if (cc === unicode_1.SQUOTE) {
            return "SQUOTE";
        }
        if (cc === unicode_1.SLASH) {
            return "SLASH";
        }
        if (cc === unicode_1.MINUS) {
            return "MINUS";
        }
        if (cc === unicode_1.PLUS) {
            return "PLUS";
        }
        if (cc === unicode_1.STAR) {
            this.commitToken("operator");
            return "SCAN";
        }
        if (isPunctuator(cc)) {
            this.commitToken("punctuator");
            return "SCAN";
        }
        if (cc === unicode_1.LBRACKET) {
            return "LBRACKET";
        }
        if (cc === unicode_1.LBRACE) {
            return "LBRACE";
        }
        if (cc === unicode_1.EOF) {
            return "SCAN";
        }
        return "WORD";
    }
    WORD(cc) {
        while (!unicode_1.isWhitespace(cc) &&
            !isPunctuator(cc) &&
            cc !== unicode_1.PLUS &&
            cc !== unicode_1.STAR &&
            cc !== unicode_1.SLASH &&
            !isQuotes(cc) &&
            cc !== unicode_1.EOF) {
            if (cc === unicode_1.MINUS) {
                const st = this.getCode();
                if (maybeNumber(st) ||
                    ((st === unicode_1.MINUS || st === unicode_1.PLUS) &&
                        maybeNumber(this.getCode(1)))) {
                    this.commitToken("word", -1);
                    return "MINUS";
                }
            }
            else if (cc === unicode_1.LBRACE || cc === unicode_1.LBRACKET || cc === unicode_1.LPAREN) {
                this.skipBrakets(this.next(), getRightBracket(cc));
            }
            cc = this.next();
        }
        this.commitToken("word", -1);
        this.back();
    }
    LBRACKET(cc) {
        this.skipBrakets(cc, unicode_1.RBRACKET);
        return "WORD";
    }
    LBRACE(cc) {
        this.skipBrakets(cc, unicode_1.RBRACE);
        return "WORD";
    }
    WHITESPACE(cc) {
        while (unicode_1.isWhitespace(cc)) {
            cc = this.next();
        }
        this.commitToken("whitespace", -1);
        this.back();
    }
    SLASH(cc) {
        if (cc === unicode_1.STAR) {
            return "COMMENT";
        }
        if (cc === unicode_1.SLASH && this.options.allowInlineCommnets) {
            return "INLINE_COMMENT";
        }
        this.commitToken("operator", -1);
        this.back();
    }
    COMMENT(cc) {
        while (cc !== unicode_1.EOF) {
            if (cc === unicode_1.STAR) {
                cc = this.next();
                if (cc === unicode_1.SLASH) {
                    this.commitToken("comment");
                    return;
                }
            }
            cc = this.next();
        }
        this.commitToken("comment", -1);
        this.reportParseError("eof-in-comment");
    }
    INLINE_COMMENT(cc) {
        while (cc !== unicode_1.EOF) {
            if (cc === unicode_1.LF || cc === unicode_1.FF) {
                this.commitToken("inline-comment");
                return;
            }
            if (cc === unicode_1.CR) {
                cc = this.next();
                if (cc === unicode_1.LF) {
                    this.commitToken("inline-comment");
                    return;
                }
                this.commitToken("inline-comment", -1);
                return this.back();
            }
            cc = this.next();
        }
        this.commitToken("inline-comment", -1);
    }
    MINUS(cc) {
        if (this.lastTokenType === "word" ||
            cc === unicode_1.EOF ||
            (cc !== unicode_1.MINUS && !maybeNumber(cc) && !unicode_1.isLetter(cc))) {
            this.commitToken("operator", -1);
            this.back();
            return;
        }
        return "WORD";
    }
    PLUS(cc) {
        if (this.lastTokenType !== "word") {
            if (maybeNumber(cc)) {
                return "WORD";
            }
        }
        this.commitToken("operator", -1);
        this.back();
    }
    DQUOTE(cc) {
        this.skipString(cc, unicode_1.DQUOTE);
    }
    SQUOTE(cc) {
        this.skipString(cc, unicode_1.SQUOTE);
    }
    skipBrakets(cc, end) {
        const closeStack = [];
        while (cc !== unicode_1.EOF) {
            if (end === cc) {
                const nextTargetBracket = closeStack.pop() || null;
                if (!nextTargetBracket) {
                    return;
                }
                end = nextTargetBracket;
            }
            else if (cc === unicode_1.LBRACE || cc === unicode_1.LBRACKET || cc === unicode_1.LPAREN) {
                if (end) {
                    closeStack.push(end);
                }
                end = getRightBracket(cc);
            }
            cc = this.next();
        }
        this.reportParseError("eof-in-bracket");
    }
    skipString(cc, end) {
        while (cc !== unicode_1.EOF) {
            if (cc === unicode_1.BACKSLASH) {
                cc = this.next();
            }
            else if (cc === end) {
                this.commitToken("string");
                return;
            }
            cc = this.next();
        }
        this.commitToken("string", -1);
        this.reportParseError("eof-in-string");
    }
};
tokenizer.Tokenizer = Tokenizer$1;
var resolvedType = {};
Object.defineProperty(resolvedType, "__esModule", { value: true });
const calc_notation_1$1 = calcNotation;
const utils_1$1 = utils;
function getResolvedType$1(expr) {
    const left = getType(expr.left);
    const right = getType(expr.right);
    const { operator } = expr;
    switch (operator) {
        case "+":
        case "-":
            if (left === "Unknown" || right === "Unknown") {
                return "Unknown";
            }
            if (left === right) {
                return left;
            }
            if (left === "Number" || right === "Number") {
                return "invalid";
            }
            if (left === "Percentage") {
                return right;
            }
            if (right === "Percentage") {
                return left;
            }
            return "invalid";
        case "*":
            if (left === "Unknown" || right === "Unknown") {
                return "Unknown";
            }
            if (left === "Number") {
                return right;
            }
            if (right === "Number") {
                return left;
            }
            return "invalid";
        case "/":
            if (right === "Unknown") {
                return "Unknown";
            }
            if (right === "Number") {
                return left;
            }
            return "invalid";
    }
    return "Unknown";
}
resolvedType.getResolvedType = getResolvedType$1;
function getExpressionType(expr) {
    const { type } = expr;
    if (type === "Number" ||
        type === "Length" ||
        type === "Angle" ||
        type === "Time" ||
        type === "Frequency" ||
        type === "Resolution" ||
        type === "Percentage" ||
        type === "Flex") {
        return type;
    }
    return "Unknown";
}
function getType(expr) {
    if (expr.type === "MathExpression") {
        const rtype = getResolvedType$1(expr);
        return rtype === "invalid" ? "Unknown" : rtype;
    }
    if (expr.type === "Parentheses") {
        if (expr.nodes.length === 1) {
            return getType(expr.nodes[0]);
        }
        return "Unknown";
    }
    if (expr.type === "Function") {
        if (calc_notation_1$1.isCalc(expr.name)) {
            return getCalcFunctionType(expr);
        }
        if (calc_notation_1$1.isMin(expr.name) || calc_notation_1$1.isMax(expr.name)) {
            return getMinMaxFunctionType(expr);
        }
        if (calc_notation_1$1.isClamp(expr.name)) {
            return getClampFunctionType(expr);
        }
        return "Unknown";
    }
    return getExpressionType(expr);
}
function getCalcFunctionType(fn) {
    if (fn.nodes.length === 1) {
        return getFunctionArgumentsType(fn);
    }
    return "Unknown";
}
function getMinMaxFunctionType(fn) {
    return getFunctionArgumentsType(fn);
}
function getClampFunctionType(fn) {
    if (fn.nodes.length === 5) {
        return getFunctionArgumentsType(fn);
    }
    return "Unknown";
}
function getFunctionArgumentsType(fn) {
    const args = utils_1$1.getFunctionArguments(fn);
    if (!args) {
        return "Unknown";
    }
    const types = args.map(getType);
    let result = null;
    for (const type of types) {
        if (!result || result === "Percentage") {
            result = type;
        }
        else if (type === "Percentage")
            ;
        else if (result !== type) {
            return "Unknown";
        }
    }
    return result || "Unknown";
}
var reducer = {};
Object.defineProperty(reducer, "__esModule", { value: true });
const calc_notation_1 = calcNotation;
const utils_1 = utils;
function reduce(expr) {
    return reduceExpression$1(expr);
}
reducer.reduce = reduce;
function reduceMathExpression(expr) {
    const left = reduceExpression$1(expr.left);
    const right = reduceExpression$1(expr.right);
    if (!left || !right) {
        return null;
    }
    switch (expr.operator) {
        case "+":
        case "-":
            return reduceAddSub(left, expr.operator, right);
        case "/":
            return reduceDivision(left, right);
        case "*":
            return reduceMultiple(left, right);
    }
    return null;
}
function reduceAddSub(left, operator, right) {
    if (left.type !== right.type) {
        return null;
    }
    const ope = operator === "-"
        ? (ln, rn) => ln - rn
        : (ln, rn) => ln + rn;
    if (left.type === "Number") {
        return {
            type: "Number",
            value: ope(left.value, right.value),
        };
    }
    const lunit = left.unit;
    const runit = right.unit;
    if (lunit === runit) {
        return {
            type: left.type,
            value: ope(left.value, right.value),
            unit: left.unit,
        };
    }
    return null;
}
function reduceDivision(left, right) {
    if (right.type !== "Number") {
        return null;
    }
    if (left.type === "Number") {
        return {
            type: "Number",
            value: left.value / right.value,
        };
    }
    return {
        type: left.type,
        value: left.value / right.value,
        unit: left.unit,
    };
}
function reduceMultiple(left, right) {
    if (left.type === "Number") {
        if (right.type === "Number") {
            return {
                type: "Number",
                value: left.value * right.value,
            };
        }
        return {
            type: right.type,
            value: left.value * right.value,
            unit: right.unit,
        };
    }
    else if (right.type === "Number") {
        return {
            type: left.type,
            value: left.value * right.value,
            unit: left.unit,
        };
    }
    return null;
}
function reduceExpression$1(expr) {
    if (expr.type === "Number" ||
        expr.type === "Length" ||
        expr.type === "Angle" ||
        expr.type === "Time" ||
        expr.type === "Frequency" ||
        expr.type === "Resolution" ||
        expr.type === "Percentage" ||
        expr.type === "Flex") {
        return expr;
    }
    if (expr.type === "MathExpression") {
        return reduceMathExpression(expr);
    }
    if (expr.type === "Parentheses" || expr.type === "Root") {
        if (expr.nodes.length === 1) {
            return reduceExpression$1(expr.nodes[0]);
        }
    }
    else if (expr.type === "Function") {
        if (expr.type === "Function") {
            if (calc_notation_1.isCalc(expr.name)) {
                return getCalcNumber(expr);
            }
        }
    }
    return null;
}
function getCalcNumber(fn) {
    const args = utils_1.getFunctionArguments(fn);
    if (args && args.length === 1) {
        return reduceExpression$1(args[0]);
    }
    return null;
}
Object.defineProperty(cssCalc, "__esModule", { value: true });
var parser_1 = parser$1;
cssCalc.Parser = parser_1.Parser;
var tokenizer_1 = tokenizer;
cssCalc.Tokenizer = tokenizer_1.Tokenizer;
var stringifier_1 = stringifier;
cssCalc.Stringifier = stringifier_1.Stringifier;
var resolved_type_1 = resolvedType;
cssCalc.getResolvedType = resolved_type_1.getResolvedType;
var reducer_1 = reducer;
cssCalc.reduceExpression = reducer_1.reduce;
var factory_1 = factory;
cssCalc.newMathExpression = factory_1.newMathExpression;
Object.defineProperty(dist, "__esModule", { value: true });
const AST = ast;
dist.AST = AST;
const css_calc_1 = cssCalc;
dist.Parser = css_calc_1.Parser;
dist.Tokenizer = css_calc_1.Tokenizer;
dist.Stringifier = css_calc_1.Stringifier;
dist.getResolvedType = css_calc_1.getResolvedType;
var reduceExpression = dist.reduceExpression = css_calc_1.reduceExpression;
dist.mathExpr = css_calc_1.newMathExpression;
function parse$1(code, options) {
    const tokenizer = new css_calc_1.Tokenizer(code, options);
    return new css_calc_1.Parser(tokenizer, options).parse();
}
var parse_1 = dist.parse = parse$1;
function stringify(node, options) {
    const stringifier = new css_calc_1.Stringifier(options);
    return stringifier.stringify(node);
}
dist.stringify = stringify;
dist.default = {
    parse: parse$1,
    stringify,
    getResolvedType: css_calc_1.getResolvedType,
    reduceExpression: css_calc_1.reduceExpression,
    mathExpr: css_calc_1.newMathExpression,
    Parser: css_calc_1.Parser,
    Tokenizer: css_calc_1.Tokenizer,
    Stringifier: css_calc_1.Stringifier,
    AST,
};

const mathChars = ['+', '-', '*', '/'];
const parser = new Parser();
function checkIfInsideGroup(expr, fullExpr) {
    // make sure all regex-specific characters are escaped by backslashes
    const exprEscaped = expr.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    // Reg which checks whether the sub expression is fitted inside of a group ( ) in the full expression
    const reg = new RegExp(`\\(.*?${exprEscaped}.*?\\)`, 'g');
    return !!fullExpr.match(reg) || !!expr.match(/\(/g); // <-- latter is needed because an expr piece might be including the opening '(' character
}
/**
 * Checks expressions like: 8 / 4 * 7px 8 * 5px 2 * 4px
 * and divides them into 3 single values:
 * ['8 / 4 * 7px', '8 * 5px', '2 * 4px']
 *
 * It splits everything by " " spaces, then checks in which places
 * there is a space but with no math operater left or right of it,
 * then determines this must mean it's a multi-value separator
 */
function splitMultiIntoSingleValues(expr) {
    const tokens = expr.split(' ');
    const indexes = [];
    let skipNextIteration = false;
    tokens.forEach((tok, i) => {
        const left = i > 0 ? tokens[i - 1] : '';
        const right = tokens[i + 1] ?? '';
        // conditions under which math expr is valid
        const conditions = [
            mathChars.includes(tok),
            mathChars.includes(right) && mathChars.includes(left),
            left === '' && mathChars.includes(right),
            right === '' && mathChars.includes(left),
            tokens.length <= 1,
            checkIfInsideGroup(tok, expr), // exprs that aren't math expressions are okay within ( ) groups
        ];
        if (conditions.every(cond => !cond)) {
            if (!skipNextIteration) {
                indexes.push(i);
                skipNextIteration = true;
            }
            else {
                skipNextIteration = false;
            }
        }
    });
    if (indexes.length > 0) {
        indexes.push(tokens.length);
        const exprArr = [];
        let currIndex = 0;
        indexes.forEach(i => {
            const singleValue = tokens.slice(currIndex, i + 1).join(' ');
            if (singleValue) {
                exprArr.push(singleValue);
            }
            currIndex = i + 1;
        });
        return exprArr;
    }
    return [expr];
}
function parseAndReduce(expr) {
    // We check for px unit, then remove it
    const hasPx = expr.match('px');
    expr = expr.replace(/px/g, '');
    // Remove it here so we can evaluate expressions like 16px + 24px
    const calcParsed = parse_1(expr.replace(/px/g, ''), {});
    // Attempt to reduce the math expression
    const reduced = reduceExpression(calcParsed);
    let unitlessExpr = expr;
    let unit;
    // E.g. if type is Length, like 4 * 7rem would be 28rem
    if (reduced && reduced.type !== 'Number') {
        unitlessExpr = `${reduced.value}`.replace(new RegExp(reduced.unit, 'ig'), '');
        unit = reduced.unit;
    }
    // Try to evaluate expression (minus unit) with expr-eval
    let evaluated;
    try {
        evaluated = parser.evaluate(unitlessExpr);
    }
    catch (ex) {
        return expr;
    }
    // Put back the px unit if needed and if reduced doesn't come with one
    return `${Number.parseFloat(evaluated.toFixed(3))}${unit ?? (hasPx ? 'px' : '')}`;
}
function checkAndEvaluateMath(expr) {
    if (expr === undefined) {
        return expr;
    }
    const exprs = splitMultiIntoSingleValues(expr);
    const reducedExprs = exprs.map(_expr => parseAndReduce(_expr));
    return reducedExprs.join(' ');
}

/**
 * Helper: Transforms dimensions to px
 */
function transformDimension(value) {
    if (value === undefined) {
        return value;
    }
    if (`${value}`.endsWith('px')) {
        return `${value}`;
    }
    return `${value}px`;
}

const fontWeightMap = {
    thin: 100,
    extralight: 200,
    ultralight: 200,
    extraleicht: 200,
    light: 300,
    leicht: 300,
    normal: 400,
    regular: 400,
    buch: 400,
    medium: 500,
    kraeftig: 500,
    kräftig: 500,
    semibold: 600,
    demibold: 600,
    halbfett: 600,
    bold: 700,
    dreiviertelfett: 700,
    extrabold: 800,
    ultabold: 800,
    fett: 800,
    black: 900,
    heavy: 900,
    super: 900,
    extrafett: 900,
};
/**
 * Helper: Transforms fontweight keynames to fontweight numbers (100, 200, 300 ... 900)
 */
function transformFontWeights(value) {
    if (value === undefined) {
        return value;
    }
    const mapped = fontWeightMap[`${value}`.toLowerCase()];
    if (mapped) {
        return `${mapped}`;
    }
    return `${value}`;
}

/**
 * A simple guard function:
 *
 * ```js
 * Math.min(Math.max(low, value), high)
 * ```
 */
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}

class ColorError extends Error {
  constructor(color) {
    super(`Failed to parse color: "${color}"`);
  }
}
var ColorError$1 = ColorError;

/**
 * Parses a color into red, gree, blue, alpha parts
 *
 * @param color the input color. Can be a RGB, RBGA, HSL, HSLA, or named color
 */
function parseToRgba(color) {
  if (typeof color !== 'string') throw new ColorError$1(color);
  if (color.trim().toLowerCase() === 'transparent') return [0, 0, 0, 0];
  let normalizedColor = color.trim();
  normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map(x => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || 'f', 2), 16) / 255];
  }
  const hexMatch = hexRegex.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map(x => parseInt(x, 16)), parseInt(arr[3] || 'ff', 16) / 255];
  }
  const rgbaMatch = rgbaRegex.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map(x => parseInt(x, 10)), parseFloat(arr[3] || '1')];
  }
  const hslaMatch = hslaRegex.exec(normalizedColor);
  if (hslaMatch) {
    const [h, s, l, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s) !== s) throw new ColorError$1(color);
    if (guard(0, 100, l) !== l) throw new ColorError$1(color);
    return [...hslToRgb(h, s, l), Number.isNaN(a) ? 1 : a];
  }
  throw new ColorError$1(color);
}
function hash(str) {
  let hash = 5381;
  let i = str.length;
  while (i) {
    hash = hash * 33 ^ str.charCodeAt(--i);
  }

  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */
  return (hash >>> 0) % 2341;
}
const colorToInt = x => parseInt(x.replace(/_/g, ''), 36);
const compressedColorMap = '1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm'.split(' ').reduce((acc, next) => {
  const key = colorToInt(next.substring(0, 3));
  const hex = colorToInt(next.substring(3)).toString(16);

  // NOTE: padStart could be used here but it breaks Node 6 compat
  // https://github.com/ricokahler/color2k/issues/351
  let prefix = '';
  for (let i = 0; i < 6 - hex.length; i++) {
    prefix += '0';
  }
  acc[key] = `${prefix}${hex}`;
  return acc;
}, {});

/**
 * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
 */
function nameToHex(color) {
  const normalizedColorName = color.toLowerCase().trim();
  const result = compressedColorMap[hash(normalizedColorName)];
  if (!result) throw new ColorError$1(color);
  return `#${result}`;
}
const r = (str, amount) => Array.from(Array(amount)).map(() => str).join('');
const reducedHexRegex = new RegExp(`^#${r('([a-f0-9])', 3)}([a-f0-9])?$`, 'i');
const hexRegex = new RegExp(`^#${r('([a-f0-9]{2})', 3)}([a-f0-9]{2})?$`, 'i');
const rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(',\\s*(\\d+)\\s*', 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, 'i');
const hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
const namedColorRegex = /^[a-z]+$/i;
const roundColor = color => {
  return Math.round(color * 255);
};
const hslToRgb = (hue, saturation, lightness) => {
  let l = lightness / 100;
  if (saturation === 0) {
    // achromatic
    return [l, l, l].map(roundColor);
  }

  // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  const lightnessModification = l - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};

/**
 * Helper: Transforms hex rgba colors used in figma tokens:
 * rgba(#ffffff, 0.5) =? rgba(255, 255, 255, 0.5).
 * This is kind of like an alpha() function.
 */
function transformHEXRGBa(value) {
    if (value === undefined) {
        return value;
    }
    const match = /rgba\((?<hex>.+),\s*(?<alpha>.+)\)/g.exec(value);
    if (match && match.groups) {
        const { hex, alpha } = match.groups;
        const [r, g, b] = parseToRgba(hex);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    return value;
}

// A is m x n. B is n x p. product is m x p.
function multiplyMatrices (A, B) {
	let m = A.length;

	if (!Array.isArray(A[0])) {
		// A is vector, convert to [[a, b, c, ...]]
		A = [A];
	}

	if (!Array.isArray(B[0])) {
		// B is vector, convert to [[a], [b], [c], ...]]
		B = B.map(x => [x]);
	}

	let p = B[0].length;
	let B_cols = B[0].map((_, i) => B.map(x => x[i])); // transpose B
	let product = A.map(row => B_cols.map(col => {
		let ret = 0;

		if (!Array.isArray(row)) {
			for (let c of col) {
				ret += row * c;
			}

			return ret;
		}

		for (let i=0; i < row.length; i++) {
			ret += row[i] * (col[i] || 0);
		}

		return ret;
	}));

	if (m === 1) {
		product = product[0]; // Avoid [[a, b, c, ...]]
	}

	if (p === 1) {
		return product.map(x => x[0]); // Avoid [[a], [b], [c], ...]]
	}

	return product;
}

/**
 * Various utility functions
 */

/**
 * Check if a value is a string (including a String object)
 * @param {*} str - Value to check
 * @returns {boolean}
 */
function isString (str) {
	return type(str) === "string";
}

/**
 * Determine the internal JavaScript [[Class]] of an object.
 * @param {*} o - Value to check
 * @returns {string}
 */
function type (o) {
	let str = Object.prototype.toString.call(o);

	return (str.match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
}

/**
 * Round a number to a certain number of significant digits
 * @param {number} n - The number to round
 * @param {number} precision - Number of significant digits
 */
function toPrecision (n, precision) {
	n = +n;
	precision = +precision;
	let integerLength = (Math.floor(n) + "").length;

	if (precision > integerLength) {
		return +n.toFixed(precision - integerLength);
	}
	else {
		let p10 = 10 ** (integerLength - precision);
		return Math.round(n / p10) * p10;
	}
}

/**
* Parse a CSS function, regardless of its name and arguments
* @param String str String to parse
* @return {{name, args, rawArgs}}
*/
function parseFunction (str) {
	if (!str) {
		return;
	}

	str = str.trim();

	const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
	const isNumberRegex = /^-?[\d.]+$/;
	let parts = str.match(isFunctionRegex);

	if (parts) {
		// It is a function, parse args
		let args = [];
		parts[2].replace(/\/?\s*([-\w.]+(?:%|deg)?)/g, ($0, arg) => {
			if (/%$/.test(arg)) {
				// Convert percentages to 0-1 numbers
				arg = new Number(arg.slice(0, -1) / 100);
				arg.type = "<percentage>";
			}
			else if (/deg$/.test(arg)) {
				// Drop deg from degrees and convert to number
				// TODO handle other units too
				arg = new Number(+arg.slice(0, -3));
				arg.type = "<angle>";
				arg.unit = "deg";
			}
			else if (isNumberRegex.test(arg)) {
				// Convert numerical args to numbers
				arg = new Number(arg);
				arg.type = "<number>";
			}

			if ($0.startsWith("/")) {
				// It's alpha
				arg = arg instanceof Number? arg : new Number(arg);
				arg.alpha = true;
			}

			args.push(arg);
		});

		return {
			name: parts[1].toLowerCase(),
			rawName: parts[1],
			rawArgs: parts[2],
			// An argument could be (as of css-color-4):
			// a number, percentage, degrees (hue), ident (in color())
			args
		};
	}
}

function last (arr) {
	return arr[arr.length - 1];
}

function interpolate (start, end, p) {
	if (isNaN(start)) {
		return end;
	}

	if (isNaN(end)) {
		return start;
	}

	return start + (end - start) * p;
}

function interpolateInv (start, end, value) {
	return (value - start) / (end - start);
}

function mapRange (from, to, value) {
	return interpolate(to[0], to[1], interpolateInv(from[0], from[1], value));
}

function parseCoordGrammar (coordGrammars) {
	return coordGrammars.map(coordGrammar => {
		return coordGrammar.split("|").map(type => {
			type = type.trim();
			let range = type.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);

			if (range) {
				let ret = new String(range[1]);
				ret.range = [+range[2], +range[3]];
				return ret;
			}

			return type;
		});
	});
}

var util = /*#__PURE__*/Object.freeze({
	__proto__: null,
	isString: isString,
	type: type,
	toPrecision: toPrecision,
	parseFunction: parseFunction,
	last: last,
	interpolate: interpolate,
	interpolateInv: interpolateInv,
	mapRange: mapRange,
	parseCoordGrammar: parseCoordGrammar,
	multiplyMatrices: multiplyMatrices
});

/**
 * A class for adding deep extensibility to any piece of JS code
 */
class Hooks {
	add (name, callback, first) {
		if (typeof arguments[0] != "string") {
			// Multiple hooks
			for (var name in arguments[0]) {
				this.add(name, arguments[0][name], arguments[1]);
			}

			return;
		}

		(Array.isArray(name)? name : [name]).forEach(function (name) {
			this[name] = this[name] || [];

			if (callback) {
				this[name][first? "unshift" : "push"](callback);
			}
		}, this);
	}

	run (name, env) {
		this[name] = this[name] || [];
		this[name].forEach(function (callback) {
			callback.call(env && env.context? env.context : env, env);
		});
	}
}
/**
 * The instance of {@link Hooks} used throughout Color.js
 */
const hooks = new Hooks();

// Global defaults one may want to configure

var defaults = {
	gamut_mapping: "lch.c",
	precision: 5,
	deltaE: "76", // Default deltaE method
};

const WHITES = {
	// for compatibility, the four-digit chromaticity-derived ones everyone else uses
	D50: [0.3457 / 0.3585, 1.00000, (1.0 - 0.3457 - 0.3585) / 0.3585],
	D65: [0.3127 / 0.3290, 1.00000, (1.0 - 0.3127 - 0.3290) / 0.3290],
};

function getWhite (name) {
	if (Array.isArray(name)) {
		return name;
	}

	return WHITES[name];
}

// Adapt XYZ from white point W1 to W2
function adapt$1 (W1, W2, XYZ, options = {}) {
	W1 = getWhite(W1);
	W2 = getWhite(W2);

	if (!W1 || !W2) {
		throw new TypeError(`Missing white point to convert ${!W1? "from" : ""}${!W1&&!W2? "/" : ""}${!W2? "to" : ""}`);
	}

	if (W1 === W2) {
		// Same whitepoints, no conversion needed
		return XYZ;
	}

	let env = {W1, W2, XYZ, options};

	hooks.run("chromatic-adaptation-start", env);

	if (!env.M) {
		if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {
			env.M = [
				[  1.0479298208405488,    0.022946793341019088,  -0.05019222954313557 ],
				[  0.029627815688159344,  0.990434484573249,     -0.01707382502938514 ],
				[ -0.009243058152591178,  0.015055144896577895,   0.7518742899580008  ]
			];
		}
		else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {

			env.M = [
				[  0.9554734527042182,   -0.023098536874261423,  0.0632593086610217   ],
				[ -0.028369706963208136,  1.0099954580058226,    0.021041398966943008 ],
				[  0.012314001688319899, -0.020507696433477912,  1.3303659366080753   ]
			];
		}
	}

	hooks.run("chromatic-adaptation-end", env);

	if (env.M) {
		return multiplyMatrices(env.M, env.XYZ);
	}
	else {
		throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
	}
}

const ε$4 = .000075;

/**
 * Class to represent a color space
 */
class ColorSpace {
	constructor (options) {
		this.id = options.id;
		this.name = options.name;
		this.base = options.base ? ColorSpace.get(options.base) : null;
		this.aliases = options.aliases;

		if (this.base) {
			this.fromBase = options.fromBase;
			this.toBase = options.toBase;
		}

		// Coordinate metadata

		let coords = options.coords ?? this.base.coords;
		this.coords = coords;

		// White point

		let white = options.white ?? this.base.white ?? "D65";
		this.white = getWhite(white);

		// Sort out formats

		this.formats = options.formats ?? {};

		for (let name in this.formats) {
			let format = this.formats[name];
			format.type ||= "function";
			format.name ||= name;
		}

		if (options.cssId && !this.formats.functions?.color) {
			this.formats.color = { id: options.cssId };
			Object.defineProperty(this, "cssId", {value: options.cssId});
		}
		else if (this.formats?.color && !this.formats?.color.id) {
			this.formats.color.id = this.id;
		}

		// Other stuff
		this.referred = options.referred;

		// Compute ancestors and store them, since they will never change
		this.#path = this.#getPath().reverse();

		hooks.run("colorspace-init-end", this);
	}

	inGamut (coords, {epsilon = ε$4} = {}) {
		if (this.isPolar) {
			// Do not check gamut through polar coordinates
			coords = this.toBase(coords);

			return this.base.inGamut(coords, {epsilon});
		}

		let coordMeta = Object.values(this.coords);

		return coords.every((c, i) => {
			let meta = coordMeta[i];

			if (meta.type !== "angle" && meta.range) {
				if (Number.isNaN(c)) {
					// NaN is always in gamut
					return true;
				}

				let [min, max] = meta.range;
				return (min === undefined || c >= min - epsilon)
				    && (max === undefined || c <= max + epsilon);
			}

			return true;
		});
	}

	get cssId () {
		return this.formats.functions?.color?.id || this.id;
	}

	get isPolar () {
		for (let id in this.coords) {
			if (this.coords[id].type === "angle") {
				return true;
			}
		}

		return false;
	}

	#processFormat (format) {
		if (format.coords && !format.coordGrammar) {
			format.type ||= "function";
			format.name ||= "color";

			// Format has not been processed
			format.coordGrammar = parseCoordGrammar(format.coords);

			let coordFormats = Object.entries(this.coords).map(([id, coordMeta], i) => {
				// Preferred format for each coord is the first one
				let outputType = format.coordGrammar[i][0];

				let fromRange = coordMeta.range || coordMeta.refRange;
				let toRange = outputType.range, suffix = "";

				// Non-strict equals intentional since outputType could be a string object
				if (outputType == "<percentage>") {
					toRange = [0, 100];
					suffix = "%";
				}
				else if (outputType == "<angle>") {
					suffix = "deg";
				}

				return  {fromRange, toRange, suffix};
			});

			format.serializeCoords = (coords, precision) => {
				return coords.map((c, i) => {
					let {fromRange, toRange, suffix} = coordFormats[i];

					if (fromRange && toRange) {
						c = mapRange(fromRange, toRange, c);
					}

					c = toPrecision(c, precision);

					if (suffix) {
						c += suffix;
					}

					return c;
				});
			};
		}

		return format;
	}

	getFormat (format) {
		if (typeof format === "object") {
			format = this.#processFormat(format);
			return format;
		}

		let ret;
		if (format === "default") {
			// Get first format
			ret = Object.values(this.formats)[0];
		}
		else {
			ret = this.formats[format];
		}

		if (ret) {
			ret = this.#processFormat(ret);
			return ret;
		}

		return null;
	}

	#path;

	#getPath () {
		let ret = [this];

		for (let space = this; space = space.base;) {
			ret.push(space);
		}

		return ret;
	}

	to (space, coords) {
		if (arguments.length === 1) {
			[space, coords] = [space.space, space.coords];
		}

		space = ColorSpace.get(space);

		if (this === space) {
			// Same space, no change needed
			return coords;
		}

		// Convert NaN to 0, which seems to be valid in every coordinate of every color space
		coords = coords.map(c => Number.isNaN(c)? 0 : c);

		// Find connection space = lowest common ancestor in the base tree
		let myPath = this.#path;
		let otherPath = space.#path;

		let connectionSpace, connectionSpaceIndex;

		for (let i=0; i < myPath.length; i++) {
			if (myPath[i] === otherPath[i]) {
				connectionSpace = myPath[i];
				connectionSpaceIndex = i;
			}
			else {
				break;
			}
		}

		if (!connectionSpace) {
			// This should never happen
			throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
		}

		// Go up from current space to connection space
		for (let i = myPath.length - 1; i > connectionSpaceIndex; i--) {
			coords = myPath[i].toBase(coords);
		}

		// Go down from connection space to target space
		for (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) {
			coords = otherPath[i].fromBase(coords);
		}

		return coords;
	}

	from (space, coords) {
		if (arguments.length === 1) {
			[space, coords] = [space.space, space.coords];
		}

		space = ColorSpace.get(space);

		return space.to(this, coords);
	}

	toString () {
		return `${this.name} (${this.id})`;
	}

	getMinCoords () {
		let ret = [];

		for (let id in this.coords) {
			let meta = this.coords[id];
			let range = meta.range || meta.refRange;
			ret.push(range?.min ?? 0);
		}

		return ret;
	}

	static registry = {};

	// Returns array of unique color spaces
	static get all () {
		return [...new Set(Object.values(ColorSpace.registry))];
	}

	static register (id, space) {
		if (arguments.length === 1) {
			space = arguments[0];
			id = space.id;
		}

		space = this.get(space);

		if (this.registry[id] && this.registry[id] !== space) {
			throw new Error(`Duplicate color space registration: '${id}'`);
		}
		this.registry[id] = space;

		// Register aliases when called without an explicit ID.
		if (arguments.length === 1 && space.aliases) {
			for (let alias of space.aliases) {
				this.register(alias, space);
			}
		}

		return space;
	}

	/**
	 * Lookup ColorSpace object by name
	 * @param {ColorSpace | string} name
	 */
	static get (space, ...alternatives) {
		if (!space || space instanceof ColorSpace) {
			return space;
		}

		let argType = type(space);

		if (argType === "string") {
			// It's a color space id
			let ret = ColorSpace.registry[space.toLowerCase()];

			if (!ret) {
				throw new TypeError(`No color space found with id = "${space}"`);
			}

			return ret;
		}

		if (alternatives.length) {
			return ColorSpace.get(...alternatives);
		}

		throw new TypeError(`${space} is not a valid color space`);
	}

	/**
	 * Get metadata about a coordinate of a color space
	 *
	 * @static
	 * @param {Array | string} ref
	 * @param {ColorSpace | string} [workingSpace]
	 * @return {Object}
	 */
	static resolveCoord (ref, workingSpace) {
		let coordType = type(ref);
		let space, coord;

		if (coordType === "string") {
			if (ref.includes(".")) {
				// Absolute coordinate
				[space, coord] = ref.split(".");
			}
			else {
				// Relative coordinate
				[space, coord] = [, ref];
			}
		}
		else if (Array.isArray(ref)) {
			[space, coord] = ref;
		}
		else {
			// Object
			space = ref.space;
			coord = ref.coordId;
		}

		space = ColorSpace.get(space);

		if (!space) {
			space = workingSpace;
		}

		if (!space) {
			throw new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);
		}

		coordType = type(coord);

		if (coordType === "number" || coordType === "string" && coord >= 0) {
			// Resolve numerical coord
			let meta = Object.entries(space.coords)[coord];

			if (meta) {
				return {space, id: meta[0], index: coord, ...meta[1]};
			}
		}

		space = ColorSpace.get(space);

		let normalizedCoord = coord.toLowerCase();

		let i = 0;
		for (let id in space.coords) {
			let meta = space.coords[id];

			if (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) {
				return {space, id, index: i, ...meta};
			}

			i++;
		}

		throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
	}

	static DEFAULT_FORMAT = {
		type: "functions",
		name: "color",
	};
}

var XYZ_D65 = new ColorSpace({
	id: "xyz-d65",
	name: "XYZ D65",
	coords: {
		x: {name: "X"},
		y: {name: "Y"},
		z: {name: "Z"},
	},
	white: "D65",
	formats: {
		color: {
			ids: ["xyz-d65", "xyz"],
		}
	},
	aliases: ["xyz"],
});

/**
 * Convenience class for RGB color spaces
 * @extends {ColorSpace}
 */
class RGBColorSpace extends ColorSpace {
	/**
	 * Creates a new RGB ColorSpace.
	 * If coords are not specified, they will use the default RGB coords.
	 * Instead of `fromBase()` and `toBase()` functions,
	 * you can specify to/from XYZ matrices and have `toBase()` and `fromBase()` automatically generated.
	 * @param {*} options - Same options as {@link ColorSpace} plus:
	 * @param {number[][]} options.toXYZ_M - Matrix to convert to XYZ
	 * @param {number[][]} options.fromXYZ_M - Matrix to convert from XYZ
	 */
	constructor (options) {
		if (!options.coords) {
			options.coords = {
				r: {
					range: [0, 1],
					name: "Red"
				},
				g: {
					range: [0, 1],
					name: "Green"
				},
				b: {
					range: [0, 1],
					name: "Blue"
				}
			};
		}

		if (!options.base) {
			options.base = XYZ_D65;
		}

		if (options.toXYZ_M && options.fromXYZ_M) {
			options.toBase ??= rgb => {
				let xyz = multiplyMatrices(options.toXYZ_M, rgb);

				if (this.white !== this.base.white) {
					// Perform chromatic adaptation
					xyz = adapt$1(this.white, this.base.white, xyz);
				}

				return xyz;
			};

			options.fromBase ??= xyz => {
				xyz = adapt$1(this.base.white, this.white, xyz);
				return multiplyMatrices(options.fromXYZ_M, xyz);
			};
		}

		options.referred ??= "display";

		super(options);
	}
}

// CSS color to Color object
function parse (str) {
	let env = {"str": String(str)?.trim()};
	hooks.run("parse-start", env);

	if (env.color) {
		return env.color;
	}

	env.parsed = parseFunction(env.str);

	if (env.parsed) {
		// Is a functional syntax
		let name = env.parsed.name;

		if (name === "color") {
			// color() function
			let id = env.parsed.args.shift();
			let alpha = env.parsed.rawArgs.indexOf("/") > 0? env.parsed.args.pop() : 1;

			for (let space of ColorSpace.all) {
				let colorSpec = space.getFormat("color");

				if (colorSpec) {
					if (id === colorSpec.id || colorSpec.ids?.includes(id)) {
						// From https://drafts.csswg.org/css-color-4/#color-function
						// If more <number>s or <percentage>s are provided than parameters that the colorspace takes, the excess <number>s at the end are ignored.
						// If less <number>s or <percentage>s are provided than parameters that the colorspace takes, the missing parameters default to 0. (This is particularly convenient for multichannel printers where the additional inks are spot colors or varnishes that most colors on the page won’t use.)
						let argCount = Object.keys(space.coords).length;
						let coords = Array(argCount).fill(0);
						coords.forEach((_, i) => coords[i] = env.parsed.args[i] || 0);

						return {spaceId: space.id, coords, alpha};
					}
				}
			}

			// Not found
			let didYouMean = "";
			if (id in ColorSpace.registry) {
				// Used color space id instead of color() id, these are often different
				let cssId = ColorSpace.registry[id].formats?.functions?.color?.id;

				if (cssId) {
					didYouMean = `Did you mean color(${cssId})?`;
				}
			}
			throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || "Missing a plugin?"));
		}
		else {
			for (let space of ColorSpace.all) {
				// color space specific function
				let format = space.getFormat(name);
				if (format && format.type === "function") {
					let alpha = 1;

					if (format.lastAlpha || last(env.parsed.args).alpha) {
						alpha = env.parsed.args.pop();
					}

					let coords = env.parsed.args;

					if (format.coordGrammar) {
						Object.entries(space.coords).forEach(([id, coordMeta], i) => {
							let coordGrammar = format.coordGrammar[i];
							let providedType = coords[i]?.type;

							// Find grammar alternative that matches the provided type
							// Non-strict equals is intentional because we are comparing w/ string objects
							coordGrammar = coordGrammar.find(c => c == providedType);

							// Check that each coord conforms to its grammar
							if (!coordGrammar) {
								// Type does not exist in the grammar, throw
								let coordName = coordMeta.name || id;
								throw new TypeError(`${providedType} not allowed for ${coordName} in ${name}()`);
							}

							let fromRange = coordGrammar.range;

							if (providedType === "<percentage>") {
								fromRange ||= [0, 1];
							}

							let toRange = coordMeta.range || coordMeta.refRange;

							if (fromRange && toRange) {

								coords[i] = mapRange(fromRange, toRange, coords[i]);
							}
						});
					}

					return {
						spaceId: space.id,
						coords, alpha
					};
				}
			}
		}
	}
	else {
		// Custom, colorspace-specific format
		for (let space of ColorSpace.all) {

			for (let formatId in space.formats) {
				let format = space.formats[formatId];

				if (format.type !== "custom") {
					continue;
				}

				if (format.test && !format.test(env.str)) {
					continue;
				}

				let color = format.parse(env.str);

				if (color) {
					color.alpha ??= 1;
					return color;
				}
			}
		}
	}


	// If we're here, we couldn't parse
	throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
}

/**
 * Resolves a color reference (object or string) to a plain color object
 * @param {Color | {space, coords, alpha} | string} color
 * @returns {{space, coords, alpha}}
 */
function getColor (color) {
	if (!color) {
		throw new TypeError("Empty color reference");
	}

	if (isString(color)) {
		color = parse(color);
	}

	// Object fixup
	let space = color.space || color.spaceId;

	if (!(space instanceof ColorSpace)) {
		// Convert string id to color space object
		color.space = ColorSpace.get(space);
	}

	if (color.alpha === undefined) {
		color.alpha = 1;
	}

	return color;
}

/**
 * Get the coordinates of a color in another color space
 *
 * @param {string | ColorSpace} space
 * @returns {number[]}
 */
function getAll (color, space) {
	space = ColorSpace.get(space);
	return space.from(color);
}

function get (color, prop) {
	let {space, index} = ColorSpace.resolveCoord(prop, color.space);
	let coords = getAll(color, space);
	return coords[index];
}

function setAll (color, space, coords) {
	space = ColorSpace.get(space);
	color.coords = space.to(color.space, coords);
	return color;
}

// Set properties and return current instance
function set (color, prop, value) {
	color = getColor(color);

	if (arguments.length === 2 && type(arguments[1]) === "object") {
		// Argument is an object literal
		let object = arguments[1];
		for (let p in object) {
			set(color, p, object[p]);
		}
	}
	else {
		if (typeof value === "function") {
			value = value(get(color, prop));
		}

		let {space, index} = ColorSpace.resolveCoord(prop, color.space);
		let coords = getAll(color, space);
		coords[index] = value;
		setAll(color, space, coords);
	}

	return color;
}

var XYZ_D50 = new ColorSpace({
	id: "xyz-d50",
	name: "XYZ D50",
	white: "D50",
	base: XYZ_D65,
	fromBase: coords => adapt$1(XYZ_D65.white, "D50", coords),
	toBase: coords => adapt$1("D50", XYZ_D65.white, coords),
	formats: {
		color: {}
	},
});

// κ * ε  = 2^3 = 8
const ε$3 = 216/24389;  // 6^3/29^3 == (24/116)^3
const ε3$1 = 24/116;
const κ$1 = 24389/27;   // 29^3/3^3

let white$1 = WHITES.D50;

var lab = new ColorSpace({
	id: "lab",
	name: "Lab",
	coords: {
		l: {
			refRange: [0, 100],
			name: "L"
		},
		a: {
			refRange: [-125, 125]
		},
		b: {
			refRange: [-125, 125]
		}
	},

	// Assuming XYZ is relative to D50, convert to CIE Lab
	// from CIE standard, which now defines these as a rational fraction
	white: white$1,

	base: XYZ_D50,
	// Convert D50-adapted XYX to Lab
	//  CIE 15.3:2004 section 8.2.1.1
	fromBase (XYZ) {
		// compute xyz, which is XYZ scaled relative to reference white
		let xyz = XYZ.map((value, i) => value / white$1[i]);

		// now compute f
		let f = xyz.map(value => value > ε$3 ? Math.cbrt(value) : (κ$1 * value + 16)/116);

		return [
			(116 * f[1]) - 16, 	 // L
			500 * (f[0] - f[1]), // a
			200 * (f[1] - f[2])  // b
		];
	},
	// Convert Lab to D50-adapted XYZ
	// Same result as CIE 15.3:2004 Appendix D although the derivation is different
	// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
	toBase (Lab) {
		// compute f, starting with the luminance-related term
		let f = [];
		f[1] = (Lab[0] + 16)/116;
		f[0] = Lab[1]/500 + f[1];
		f[2] = f[1] - Lab[2]/200;

		// compute xyz
		let xyz = [
			f[0]   > ε3$1  ?  Math.pow(f[0], 3)            : (116*f[0]-16)/κ$1,
			Lab[0] > 8   ?  Math.pow((Lab[0]+16)/116, 3) : Lab[0]/κ$1,
			f[2]   > ε3$1  ?  Math.pow(f[2], 3)            : (116*f[2]-16)/κ$1
		];

		// Compute XYZ by scaling xyz by reference white
		return xyz.map((value, i) => value * white$1[i]);
	},

	formats: {
		"lab": {
			coords: ["<number> | <percentage>", "<number>", "<number>"],
		}
	}
});

function constrain (angle) {
	return ((angle % 360) + 360) % 360;
}

function adjust (arc, angles) {
	if (arc === "raw") {
		return angles;
	}

	let [a1, a2] = angles.map(constrain);

	let angleDiff = a2 - a1;

	if (arc === "increasing") {
		if (angleDiff < 0) {
			a2 += 360;
		}
	}
	else if (arc === "decreasing") {
		if (angleDiff > 0) {
			a1 += 360;
		}
	}
	else if (arc === "longer") {
		if (-180 < angleDiff && angleDiff < 180) {
			if (angleDiff > 0) {
				a2 += 360;
			}
			else {
				a1 += 360;
			}
		}
	}
	else if (arc === "shorter") {
		if (angleDiff > 180) {
			a1 += 360;
		}
		else if (angleDiff < -180) {
			a2 += 360;
		}
	}

	return [a1, a2];
}

var lch = new ColorSpace({
	id: "lch",
	name: "LCH",
	coords: {
		l: {
			refRange: [0, 100],
			name: "Lightness"
		},
		c: {
			refRange: [0, 150],
			name: "Chroma"
		},
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		}
	},

	base: lab,
	fromBase (Lab) {
		// Convert to polar form
		let [L, a, b] = Lab;
		let hue;
		const ε = 0.02;

		if (Math.abs(a) < ε && Math.abs(b) < ε) {
			hue = NaN;
		}
		else {
			hue = Math.atan2(b, a) * 180 / Math.PI;
		}

		return [
			L, // L is still L
			Math.sqrt(a ** 2 + b ** 2), // Chroma
			constrain(hue) // Hue, in degrees [0 to 360)
		];
	},
	toBase (LCH) {
		// Convert from polar form
		let [Lightness, Chroma, Hue] = LCH;
		// Clamp any negative Chroma
		if (Chroma < 0) {
			Chroma = 0;
		}		// Deal with NaN Hue
		if (isNaN(Hue)) {
			Hue = 0;
		}
		return [
			Lightness, // L is still L
			Chroma * Math.cos(Hue * Math.PI / 180), // a
			Chroma * Math.sin(Hue * Math.PI / 180)  // b
		];
	},

	formats: {
		"lch": {
			coords: ["<number> | <percentage>", "<number>", "<number> | <angle>"],
		}
	}
});

// deltaE2000 is a statistically significant improvement
// and is recommended by the CIE and Idealliance
// especially for color differences less than 10 deltaE76
// but is wicked complicated
// and many implementations have small errors!
// DeltaE2000 is also discontinuous; in case this
// matters to you, use deltaECMC instead.

const Gfactor = 25 ** 7;
const π$1 = Math.PI;
const r2d = 180 / π$1;
const d2r$1 = π$1 / 180;

function deltaE2000 (color, sample, {kL = 1, kC = 1, kH = 1} = {}) {
	// Given this color as the reference
	// and the function parameter as the sample,
	// calculate deltaE 2000.

	// This implementation assumes the parametric
	// weighting factors kL, kC and kH
	// for the influence of viewing conditions
	// are all 1, as sadly seems typical.
	// kL should be increased for lightness texture or noise
	// and kC increased for chroma noise

	let [L1, a1, b1] = lab.from(color);
	let C1 = lch.from(lab, [L1, a1, b1])[1];
	let [L2, a2, b2] = lab.from(sample);
	let C2 = lch.from(lab, [L2, a2, b2])[1];

	// Check for negative Chroma,
	// which might happen through
	// direct user input of LCH values

	if (C1 < 0) {
		C1 = 0;
	}
	if (C2 < 0) {
		C2 = 0;
	}

	let Cbar = (C1 + C2)/2; // mean Chroma

	// calculate a-axis asymmetry factor from mean Chroma
	// this turns JND ellipses for near-neutral colors back into circles
	let C7 = Cbar ** 7;

	let G = 0.5 * (1 - Math.sqrt(C7/(C7 + Gfactor)));

	// scale a axes by asymmetry factor
	// this by the way is why there is no Lab2000 colorspace
	let adash1 = (1 + G) * a1;
	let adash2 = (1 + G) * a2;

	// calculate new Chroma from scaled a and original b axes
	let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
	let Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);

	// calculate new hues, with zero hue for true neutrals
	// and in degrees, not radians

	let h1 = (adash1 === 0 && b1 === 0)? 0: Math.atan2(b1, adash1);
	let h2 = (adash2 === 0 && b2 === 0)? 0: Math.atan2(b2, adash2);

	if (h1 < 0) {
		h1 += 2 * π$1;
	}
	if (h2 < 0) {
		h2 += 2 * π$1;
	}

	h1 *= r2d;
	h2 *= r2d;

	// Lightness and Chroma differences; sign matters
	let ΔL = L2 - L1;
	let ΔC = Cdash2 - Cdash1;

	// Hue difference, getting the sign correct
	let hdiff = h2 - h1;
	let hsum = h1 + h2;
	let habs = Math.abs(hdiff);
	let Δh;

	if (Cdash1 * Cdash2 === 0) {
		Δh = 0;
	}
	else if (habs <= 180) {
		Δh = hdiff;
	}
	else if (hdiff > 180) {
		Δh = hdiff - 360;
	}
	else if (hdiff < -180) {
		Δh = hdiff + 360;
	}
	else {
		console.log("the unthinkable has happened");
	}

	// weighted Hue difference, more for larger Chroma
	let ΔH = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(Δh * d2r$1 / 2);

	// calculate mean Lightness and Chroma
	let Ldash = (L1 + L2)/2;
	let Cdash = (Cdash1 + Cdash2)/2;
	let Cdash7 = Math.pow(Cdash, 7);

	// Compensate for non-linearity in the blue region of Lab.
	// Four possibilities for hue weighting factor,
	// depending on the angles, to get the correct sign
	let hdash;
	if (Cdash1 * Cdash2 === 0) {
		hdash = hsum;   // which should be zero
	}
	else if (habs <= 180) {
		hdash = hsum / 2;
	}
	else if (hsum < 360) {
		hdash = (hsum + 360) / 2;
	}
	else {
		hdash = (hsum - 360) / 2;
	}

	// positional corrections to the lack of uniformity of CIELAB
	// These are all trying to make JND ellipsoids more like spheres

	// SL Lightness crispening factor
	// a background with L=50 is assumed
	let lsq = (Ldash - 50) ** 2;
	let SL = 1 + ((0.015 * lsq) / Math.sqrt(20 + lsq));

	// SC Chroma factor, similar to those in CMC and deltaE 94 formulae
	let SC = 1 + 0.045 * Cdash;

	// Cross term T for blue non-linearity
	let T = 1;
	T -= (0.17 * Math.cos((     hdash - 30)  * d2r$1));
	T += (0.24 * Math.cos(  2 * hdash        * d2r$1));
	T += (0.32 * Math.cos(((3 * hdash) + 6)  * d2r$1));
	T -= (0.20 * Math.cos(((4 * hdash) - 63) * d2r$1));

	// SH Hue factor depends on Chroma,
	// as well as adjusted hue angle like deltaE94.
	let SH = 1 + 0.015 * Cdash * T;

	// RT Hue rotation term compensates for rotation of JND ellipses
	// and Munsell constant hue lines
	// in the medium-high Chroma blue region
	// (Hue 225 to 315)
	let Δθ = 30 * Math.exp(-1 * (((hdash - 275)/25) ** 2));
	let RC = 2 * Math.sqrt(Cdash7/(Cdash7 + Gfactor));
	let RT = -1 * Math.sin(2 * Δθ * d2r$1) * RC;

	// Finally calculate the deltaE, term by term as root sume of squares
	let dE = (ΔL / (kL * SL)) ** 2;
	dE += (ΔC / (kC * SC)) ** 2;
	dE += (ΔH / (kH * SH)) ** 2;
	dE += RT * (ΔC / (kC * SC)) * (ΔH / (kH * SH));
	return Math.sqrt(dE);
	// Yay!!!
}

const ε$2 = .000075;

/**
 * Check if a color is in gamut of either its own or another color space
 * @return {Boolean} Is the color in gamut?
 */
function inGamut (color, space = color.space, {epsilon = ε$2} = {}) {
	color = getColor(color);
	space = ColorSpace.get(space);
	let coords = color.coords;

	if (space !== color.space) {
		coords = space.from(color);
	}

	return space.inGamut(coords, {epsilon});
}

function clone (color) {
	return {
		space: color.space,
		coords: color.coords.slice(),
		alpha: color.alpha
	};
}

/**
 * Force coordinates to be in gamut of a certain color space.
 * Mutates the color it is passed.
 * @param {Object} options
 * @param {string} options.method - How to force into gamut.
 *        If "clip", coordinates are just clipped to their reference range.
 *        If in the form [colorSpaceId].[coordName], that coordinate is reduced
 *        until the color is in gamut. Please note that this may produce nonsensical
 *        results for certain coordinates (e.g. hue) or infinite loops if reducing the coordinate never brings the color in gamut.
 * @param {ColorSpace|string} options.space - The space whose gamut we want to map to
 */
function toGamut (color, {method = defaults.gamut_mapping, space = color.space} = {}) {
	if (isString(arguments[1])) {
		space = arguments[1];
	}

	space = ColorSpace.get(space);

	if (inGamut(color, space, {epsilon: 0})) {
		return color;
	}

	// 3 spaces:
	// color.space: current color space
	// space: space whose gamut we are mapping to
	// mapSpace: space with the coord we're reducing
	let spaceColor = to(color, space);

	if (method !== "clip" && !inGamut(color, space)) {
		let clipped = toGamut(clone(spaceColor), {method: "clip", space});
		if (deltaE2000(color, clipped) > 2) {
			// Reduce a coordinate of a certain color space until the color is in gamut
			let coordMeta = ColorSpace.resolveCoord(method);
			let mapSpace = coordMeta.space;
			let coordId = coordMeta.id;

			let mappedColor = to(spaceColor, mapSpace);
			let bounds = coordMeta.range || coordMeta.refRange;
			let min = bounds[0];
			let ε = .01; // for deltaE
			let low = min;
			let high = get(mappedColor, coordId);

			while (high - low > ε) {
				let clipped = clone(mappedColor);
				clipped = toGamut(clipped, {space, method: "clip"});
				let deltaE = deltaE2000(mappedColor, clipped);

				if (deltaE - 2 < ε) {
					low = get(mappedColor, coordId);
				}
				else {
					high = get(mappedColor, coordId);
				}

				set(mappedColor, coordId, (low + high) / 2);
			}

			spaceColor = to(mappedColor, space);
		}
		else {
			spaceColor = clipped;
		}
	}

	if (method === "clip" // Dumb coord clipping
		// finish off smarter gamut mapping with clip to get rid of ε, see #17
		|| !inGamut(spaceColor, space, {epsilon: 0})
	) {
		let bounds = Object.values(space.coords).map(c => c.range || []);

		spaceColor.coords = spaceColor.coords.map((c, i) => {
			let [min, max] = bounds[i];

			if (min !== undefined) {
				c = Math.max(min, c);
			}

			if (max !== undefined) {
				c = Math.min(c, max);
			}

			return c;
		});
	}

	if (space !== color.space) {
		spaceColor = to(spaceColor, color.space);
	}

	color.coords = spaceColor.coords;
	return color;
}

toGamut.returns = "color";

/**
 * Convert to color space and return a new color
 * @param {Object|string} space - Color space object or id
 * @param {Object} options
 * @param {boolean} options.inGamut - Whether to force resulting color in gamut
 * @returns {Color}
 */
function to (color, space, {inGamut} = {}) {
	color = getColor(color);
	space = ColorSpace.get(space);

	let coords = space.from(color);
	let ret = {space, coords, alpha: color.alpha};

	if (inGamut) {
		ret = toGamut(ret);
	}

	return ret;
}

to.returns = "color";

/**
 * Generic toString() method, outputs a color(spaceId ...coords) function, a functional syntax, or custom formats defined by the color space
 * @param {Object} options
 * @param {number} options.precision - Significant digits
 * @param {boolean} options.inGamut - Adjust coordinates to fit in gamut first? [default: false]
 */
function serialize (color, {
	precision = defaults.precision,
	format = "default",
	inGamut: inGamut$1 = true,
	...customOptions
} = {}) {
	let ret;

	color = getColor(color);

	let formatId = format;
	format = color.space.getFormat(format)
		   ?? color.space.getFormat("default")
		   ?? ColorSpace.DEFAULT_FORMAT;

	inGamut$1 ||= format.toGamut;

	let coords = color.coords;

	// Convert NaN to zeros to have a chance at a valid CSS color
	// Also convert -0 to 0
	// This also clones it so we can manipulate it
	coords = coords.map(c => c? c : 0);

	if (inGamut$1 && !inGamut(color)) {
		coords = toGamut(clone(color), inGamut$1 === true? undefined : inGamut$1).coords;
	}

	if (format.type === "custom") {
		customOptions.precision = precision;

		if (format.serialize) {
			ret = format.serialize(coords, color.alpha, customOptions);
		}
		else {
			throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
		}
	}
	else {
		// Functional syntax
		let name = format.name || "color";

		if (format.serializeCoords) {
			coords = format.serializeCoords(coords, precision);
		}
		else {
			if (precision !== null) {
				coords = coords.map(c => toPrecision(c, precision));
			}
		}

		let args = [...coords];

		if (name === "color") {
			// If output is a color() function, add colorspace id as first argument
			let cssId = format.id || format.ids?.[0] || color.space.id;
			args.unshift(cssId);
		}

		let alpha = color.alpha;
		if (precision !== null) {
			alpha = toPrecision(alpha, precision);
		}

		let strAlpha = color.alpha < 1 && !format.noAlpha? `${format.commas? "," : " /"} ${alpha}` : "";
		ret = `${name}(${args.join(format.commas? ", " : " ")}${strAlpha})`;
	}

	return ret;
}

// convert an array of linear-light rec2020 values to CIE XYZ
// using  D65 (no chromatic adaptation)
// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
// 0 is actually calculated as  4.994106574466076e-17
const toXYZ_M$5 = [
	[ 0.6369580483012914, 0.14461690358620832,  0.1688809751641721  ],
	[ 0.2627002120112671, 0.6779980715188708,   0.05930171646986196 ],
	[ 0.000000000000000,  0.028072693049087428, 1.060985057710791   ]
];

// from ITU-R BT.2124-0 Annex 2 p.3
const fromXYZ_M$5 = [
	[  1.716651187971268,  -0.355670783776392, -0.253366281373660  ],
	[ -0.666684351832489,   1.616481236634939,  0.0157685458139111 ],
	[  0.017639857445311,  -0.042770613257809,  0.942103121235474  ]
];

var REC2020Linear = new RGBColorSpace({
	id: "rec2020-linear",
	name: "Linear REC.2020",
	white: "D65",
	toXYZ_M: toXYZ_M$5,
	fromXYZ_M: fromXYZ_M$5,
	formats: {
		color: {},
	}
});

// import sRGB from "./srgb.js";

const α = 1.09929682680944;
const β = 0.018053968510807;

var REC2020 = new RGBColorSpace({
	id: "rec2020",
	name: "REC.2020",
	base: REC2020Linear,
	// Non-linear transfer function from Rec. ITU-R BT.2020-2 table 4
	toBase (RGB) {
		return RGB.map(function (val) {
			if (val < β * 4.5 ) {
				return val / 4.5;
			}

			return Math.pow((val + α -1 ) / α, 1/0.45);
		});
	},
	fromBase (RGB) {
		return RGB.map(function (val) {
			if (val >= β ) {
				return α * Math.pow(val, 0.45) - (α - 1);
			}

			return 4.5 * val;
		});
	},
	formats: {
		color: {},
	}
});

const toXYZ_M$4 = [
	[0.4865709486482162, 0.26566769316909306, 0.1982172852343625],
	[0.2289745640697488, 0.6917385218365064,  0.079286914093745],
	[0.0000000000000000, 0.04511338185890264, 1.043944368900976]
];

const fromXYZ_M$4 = [
	[ 2.493496911941425,   -0.9313836179191239, -0.40271078445071684],
	[-0.8294889695615747,   1.7626640603183463,  0.023624685841943577],
	[ 0.03584583024378447, -0.07617238926804182, 0.9568845240076872]
];

var P3Linear = new RGBColorSpace({
	id: "p3-linear",
	name: "Linear P3",
	white: "D65",
	toXYZ_M: toXYZ_M$4,
	fromXYZ_M: fromXYZ_M$4
});

// This is the linear-light version of sRGB
// as used for example in SVG filters
// or in Canvas

// This matrix was calculated directly from the RGB and white chromaticities
// when rounded to 8 decimal places, it agrees completely with the official matrix
// see https://github.com/w3c/csswg-drafts/issues/5922
const toXYZ_M$3 = [
	[ 0.41239079926595934, 0.357584339383878,   0.1804807884018343  ],
	[ 0.21263900587151027, 0.715168678767756,   0.07219231536073371 ],
	[ 0.01933081871559182, 0.11919477979462598, 0.9505321522496607  ]
];

// This matrix is the inverse of the above;
// again it agrees with the official definition when rounded to 8 decimal places
const fromXYZ_M$3 = [
	[  3.2409699419045226,  -1.537383177570094,   -0.4986107602930034  ],
	[ -0.9692436362808796,   1.8759675015077202,   0.04155505740717559 ],
	[  0.05563007969699366, -0.20397695888897652,  1.0569715142428786  ]
];

var sRGBLinear = new RGBColorSpace({
	id: "srgb-linear",
	name: "Linear sRGB",
	white: "D65",
	toXYZ_M: toXYZ_M$3,
	fromXYZ_M: fromXYZ_M$3,
	formats: {
		color: {}
	},
});

/* List of CSS color keywords
 * Note that this does not include currentColor, transparent,
 * or system colors
 */

// To produce: Visit https://www.w3.org/TR/css-color-4/#named-colors
// and run in the console:
// copy($$("tr", $(".named-color-table tbody")).map(tr => `"${tr.cells[2].textContent.trim()}": [${tr.cells[4].textContent.trim().split(/\s+/).map(c => c === "0"? "0" : c === "255"? "1" : c + " / 255").join(", ")}]`).join(",\n"))
var KEYWORDS = {
	"aliceblue": [240 / 255, 248 / 255, 1],
	"antiquewhite": [250 / 255, 235 / 255, 215 / 255],
	"aqua": [0, 1, 1],
	"aquamarine": [127 / 255, 1, 212 / 255],
	"azure": [240 / 255, 1, 1],
	"beige": [245 / 255, 245 / 255, 220 / 255],
	"bisque": [1, 228 / 255, 196 / 255],
	"black": [0, 0, 0],
	"blanchedalmond": [1, 235 / 255, 205 / 255],
	"blue": [0, 0, 1],
	"blueviolet": [138 / 255, 43 / 255, 226 / 255],
	"brown": [165 / 255, 42 / 255, 42 / 255],
	"burlywood": [222 / 255, 184 / 255, 135 / 255],
	"cadetblue": [95 / 255, 158 / 255, 160 / 255],
	"chartreuse": [127 / 255, 1, 0],
	"chocolate": [210 / 255, 105 / 255, 30 / 255],
	"coral": [1, 127 / 255, 80 / 255],
	"cornflowerblue": [100 / 255, 149 / 255, 237 / 255],
	"cornsilk": [1, 248 / 255, 220 / 255],
	"crimson": [220 / 255, 20 / 255, 60 / 255],
	"cyan": [0, 1, 1],
	"darkblue": [0, 0, 139 / 255],
	"darkcyan": [0, 139 / 255, 139 / 255],
	"darkgoldenrod": [184 / 255, 134 / 255, 11 / 255],
	"darkgray": [169 / 255, 169 / 255, 169 / 255],
	"darkgreen": [0, 100 / 255, 0],
	"darkgrey": [169 / 255, 169 / 255, 169 / 255],
	"darkkhaki": [189 / 255, 183 / 255, 107 / 255],
	"darkmagenta": [139 / 255, 0, 139 / 255],
	"darkolivegreen": [85 / 255, 107 / 255, 47 / 255],
	"darkorange": [1, 140 / 255, 0],
	"darkorchid": [153 / 255, 50 / 255, 204 / 255],
	"darkred": [139 / 255, 0, 0],
	"darksalmon": [233 / 255, 150 / 255, 122 / 255],
	"darkseagreen": [143 / 255, 188 / 255, 143 / 255],
	"darkslateblue": [72 / 255, 61 / 255, 139 / 255],
	"darkslategray": [47 / 255, 79 / 255, 79 / 255],
	"darkslategrey": [47 / 255, 79 / 255, 79 / 255],
	"darkturquoise": [0, 206 / 255, 209 / 255],
	"darkviolet": [148 / 255, 0, 211 / 255],
	"deeppink": [1, 20 / 255, 147 / 255],
	"deepskyblue": [0, 191 / 255, 1],
	"dimgray": [105 / 255, 105 / 255, 105 / 255],
	"dimgrey": [105 / 255, 105 / 255, 105 / 255],
	"dodgerblue": [30 / 255, 144 / 255, 1],
	"firebrick": [178 / 255, 34 / 255, 34 / 255],
	"floralwhite": [1, 250 / 255, 240 / 255],
	"forestgreen": [34 / 255, 139 / 255, 34 / 255],
	"fuchsia": [1, 0, 1],
	"gainsboro": [220 / 255, 220 / 255, 220 / 255],
	"ghostwhite": [248 / 255, 248 / 255, 1],
	"gold": [1, 215 / 255, 0],
	"goldenrod": [218 / 255, 165 / 255, 32 / 255],
	"gray": [128 / 255, 128 / 255, 128 / 255],
	"green": [0, 128 / 255, 0],
	"greenyellow": [173 / 255, 1, 47 / 255],
	"grey": [128 / 255, 128 / 255, 128 / 255],
	"honeydew": [240 / 255, 1, 240 / 255],
	"hotpink": [1, 105 / 255, 180 / 255],
	"indianred": [205 / 255, 92 / 255, 92 / 255],
	"indigo": [75 / 255, 0, 130 / 255],
	"ivory": [1, 1, 240 / 255],
	"khaki": [240 / 255, 230 / 255, 140 / 255],
	"lavender": [230 / 255, 230 / 255, 250 / 255],
	"lavenderblush": [1, 240 / 255, 245 / 255],
	"lawngreen": [124 / 255, 252 / 255, 0],
	"lemonchiffon": [1, 250 / 255, 205 / 255],
	"lightblue": [173 / 255, 216 / 255, 230 / 255],
	"lightcoral": [240 / 255, 128 / 255, 128 / 255],
	"lightcyan": [224 / 255, 1, 1],
	"lightgoldenrodyellow": [250 / 255, 250 / 255, 210 / 255],
	"lightgray": [211 / 255, 211 / 255, 211 / 255],
	"lightgreen": [144 / 255, 238 / 255, 144 / 255],
	"lightgrey": [211 / 255, 211 / 255, 211 / 255],
	"lightpink": [1, 182 / 255, 193 / 255],
	"lightsalmon": [1, 160 / 255, 122 / 255],
	"lightseagreen": [32 / 255, 178 / 255, 170 / 255],
	"lightskyblue": [135 / 255, 206 / 255, 250 / 255],
	"lightslategray": [119 / 255, 136 / 255, 153 / 255],
	"lightslategrey": [119 / 255, 136 / 255, 153 / 255],
	"lightsteelblue": [176 / 255, 196 / 255, 222 / 255],
	"lightyellow": [1, 1, 224 / 255],
	"lime": [0, 1, 0],
	"limegreen": [50 / 255, 205 / 255, 50 / 255],
	"linen": [250 / 255, 240 / 255, 230 / 255],
	"magenta": [1, 0, 1],
	"maroon": [128 / 255, 0, 0],
	"mediumaquamarine": [102 / 255, 205 / 255, 170 / 255],
	"mediumblue": [0, 0, 205 / 255],
	"mediumorchid": [186 / 255, 85 / 255, 211 / 255],
	"mediumpurple": [147 / 255, 112 / 255, 219 / 255],
	"mediumseagreen": [60 / 255, 179 / 255, 113 / 255],
	"mediumslateblue": [123 / 255, 104 / 255, 238 / 255],
	"mediumspringgreen": [0, 250 / 255, 154 / 255],
	"mediumturquoise": [72 / 255, 209 / 255, 204 / 255],
	"mediumvioletred": [199 / 255, 21 / 255, 133 / 255],
	"midnightblue": [25 / 255, 25 / 255, 112 / 255],
	"mintcream": [245 / 255, 1, 250 / 255],
	"mistyrose": [1, 228 / 255, 225 / 255],
	"moccasin": [1, 228 / 255, 181 / 255],
	"navajowhite": [1, 222 / 255, 173 / 255],
	"navy": [0, 0, 128 / 255],
	"oldlace": [253 / 255, 245 / 255, 230 / 255],
	"olive": [128 / 255, 128 / 255, 0],
	"olivedrab": [107 / 255, 142 / 255, 35 / 255],
	"orange": [1, 165 / 255, 0],
	"orangered": [1, 69 / 255, 0],
	"orchid": [218 / 255, 112 / 255, 214 / 255],
	"palegoldenrod": [238 / 255, 232 / 255, 170 / 255],
	"palegreen": [152 / 255, 251 / 255, 152 / 255],
	"paleturquoise": [175 / 255, 238 / 255, 238 / 255],
	"palevioletred": [219 / 255, 112 / 255, 147 / 255],
	"papayawhip": [1, 239 / 255, 213 / 255],
	"peachpuff": [1, 218 / 255, 185 / 255],
	"peru": [205 / 255, 133 / 255, 63 / 255],
	"pink": [1, 192 / 255, 203 / 255],
	"plum": [221 / 255, 160 / 255, 221 / 255],
	"powderblue": [176 / 255, 224 / 255, 230 / 255],
	"purple": [128 / 255, 0, 128 / 255],
	"rebeccapurple": [102 / 255, 51 / 255, 153 / 255],
	"red": [1, 0, 0],
	"rosybrown": [188 / 255, 143 / 255, 143 / 255],
	"royalblue": [65 / 255, 105 / 255, 225 / 255],
	"saddlebrown": [139 / 255, 69 / 255, 19 / 255],
	"salmon": [250 / 255, 128 / 255, 114 / 255],
	"sandybrown": [244 / 255, 164 / 255, 96 / 255],
	"seagreen": [46 / 255, 139 / 255, 87 / 255],
	"seashell": [1, 245 / 255, 238 / 255],
	"sienna": [160 / 255, 82 / 255, 45 / 255],
	"silver": [192 / 255, 192 / 255, 192 / 255],
	"skyblue": [135 / 255, 206 / 255, 235 / 255],
	"slateblue": [106 / 255, 90 / 255, 205 / 255],
	"slategray": [112 / 255, 128 / 255, 144 / 255],
	"slategrey": [112 / 255, 128 / 255, 144 / 255],
	"snow": [1, 250 / 255, 250 / 255],
	"springgreen": [0, 1, 127 / 255],
	"steelblue": [70 / 255, 130 / 255, 180 / 255],
	"tan": [210 / 255, 180 / 255, 140 / 255],
	"teal": [0, 128 / 255, 128 / 255],
	"thistle": [216 / 255, 191 / 255, 216 / 255],
	"tomato": [1, 99 / 255, 71 / 255],
	"turquoise": [64 / 255, 224 / 255, 208 / 255],
	"violet": [238 / 255, 130 / 255, 238 / 255],
	"wheat": [245 / 255, 222 / 255, 179 / 255],
	"white": [1, 1, 1],
	"whitesmoke": [245 / 255, 245 / 255, 245 / 255],
	"yellow": [1, 1, 0],
	"yellowgreen": [154 / 255, 205 / 255, 50 / 255]
};

let coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
let coordGrammarNumber = Array(3).fill("<number>[0, 255]");

var sRGB = new RGBColorSpace({
	id: "srgb",
	name: "sRGB",
	base: sRGBLinear,
	fromBase: rgb => {
		// convert an array of linear-light sRGB values in the range 0.0-1.0
		// to gamma corrected form
		// https://en.wikipedia.org/wiki/SRGB
		return rgb.map(val => {
			let sign = val < 0? -1 : 1;
			let abs = val * sign;

			if (abs > 0.0031308) {
				return sign * (1.055 * (abs ** (1/2.4)) - 0.055);
			}

			return 12.92 * val;
		});
	},
	toBase: rgb => {
		// convert an array of sRGB values in the range 0.0 - 1.0
		// to linear light (un-companded) form.
		// https://en.wikipedia.org/wiki/SRGB
		return rgb.map(val => {
			let sign = val < 0? -1 : 1;
			let abs = val * sign;

			if (abs < 0.04045) {
				return val / 12.92;
			}

			return sign * (((abs + 0.055) / 1.055) ** 2.4);
		});
	},
	formats: {
		"rgb": {
			coords: coordGrammar,
		},
		"rgb_number": {
			name: "rgb",
			commas: true,
			coords: coordGrammarNumber,
			noAlpha: true,
		},
		"color": { /* use defaults */ },
		"rgba": {
			coords: coordGrammar,
			commas: true,
			lastAlpha: true,
		},
		"rgba_number": {
			name: "rgba",
			commas: true,
			coords: coordGrammarNumber
		},
		"hex": {
			type: "custom",
			toGamut: true,
			test: str => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
			parse (str) {
				if (str.length <= 5) {
					// #rgb or #rgba, duplicate digits
					str = str.replace(/[a-f0-9]/gi, "$&$&");
				}

				let rgba = [];
				str.replace(/[a-f0-9]{2}/gi, component => {
					rgba.push(parseInt(component, 16) / 255);
				});

				return {
					spaceId: "srgb",
					coords: rgba.slice(0, 3),
					alpha: rgba.slice(3)[0]
				};
			},
			serialize: (coords, alpha, {
				collapse = true // collapse to 3-4 digit hex when possible?
			} = {}) => {
				if (alpha < 1) {
					coords.push(alpha);
				}

				coords = coords.map(c => Math.round(c * 255));

				let collapsible = collapse && coords.every(c => c % 17 === 0);

				let hex = coords.map(c => {
					if (collapsible) {
						return (c/17).toString(16);
					}

					return c.toString(16).padStart(2, "0");
				}).join("");

				return "#" + hex;
			}
		},
		"keyword": {
			type: "custom",
			test: str => /^[a-z]+$/i.test(str),
			parse (str) {
				str = str.toLowerCase();
				let ret = {spaceId: "srgb", coords: null, alpha: 1};

				if (str === "transparent") {
					ret.coords = KEYWORDS.black;
					ret.alpha = 0;
				}
				else {
					ret.coords = KEYWORDS[str];
				}

				if (ret.coords) {
					return ret;
				}
			}
		},
	}
});

var P3 = new RGBColorSpace({
	id: "p3",
	name: "P3",
	base: P3Linear,
	// Gamma encoding/decoding is the same as sRGB
	fromBase: sRGB.fromBase,
	toBase: sRGB.toBase,
	formats: {
		color: {
			id: "display-p3",
		}
	},
});

// Default space for CSS output. Code in Color.js makes this wider if there's a DOM available
defaults.display_space = sRGB;

if (typeof CSS !== "undefined" && CSS.supports) {
	// Find widest supported color space for CSS
	for (let space of [lab, REC2020, P3]) {
		let coords = space.getMinCoords();
		let color = {space, coords, alpha: 1};
		let str = serialize(color);

		if (CSS.supports("color", str)) {
			defaults.display_space = space;
			break;
		}
	}
}

/**
 * Returns a serialization of the color that can actually be displayed in the browser.
 * If the default serialization can be displayed, it is returned.
 * Otherwise, the color is converted to Lab, REC2020, or P3, whichever is the widest supported.
 * In Node.js, this is basically equivalent to `serialize()` but returns a `String` object instead.
 *
 * @export
 * @param {{space, coords} | Color | string} color
 * @param {*} [options={}] Options to be passed to serialize()
 * @param {ColorSpace | string} [options.space = defaults.display_space] Color space to use for serialization if default is not supported
 * @returns {String} String object containing the serialized color with a color property containing the converted color (or the original, if no conversion was necessary)
 */
function display (color, {space = defaults.display_space, ...options} = {}) {
	let ret = serialize(color, options);

	if (typeof CSS === "undefined" || CSS.supports("color", ret) || !defaults.display_space) {
		ret = new String(ret);
		ret.color = color;
	}
	else {
		// If we're here, what we were about to output is not supported
		// Fall back to fallback space
		let fallbackColor = to(color, space);
		ret = new String(serialize(fallbackColor, options));
		ret.color = fallbackColor;
	}

	return ret;
}

/**
 * Euclidean distance of colors in an arbitrary color space
 */
function distance (color1, color2, space = "lab") {
	space = ColorSpace.get(space);

	let coords1 = space.from(color1);
	let coords2 = space.from(color2);

	return Math.sqrt(coords1.reduce((acc, c1, i) => {
		let c2 = coords2[i];
		if (isNaN(c1) || isNaN(c2)) {
			return acc;
		}

		return acc + (c2 - c1) ** 2;
	}, 0));
}

function equals (color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);

	return color1.space === color2.space
		   && color1.alpha === color2.alpha
		   && color1.coords.every((c, i) => c === color2.coords[i]);
}

/**
 * Relative luminance
 */

function getLuminance (color) {
	return get(color, [XYZ_D65, "y"]);
}

function setLuminance (color, value) {
	set(color, [XYZ_D65, "y"], value);
}

function register$2 (Color) {
	Object.defineProperty(Color.prototype, "luminance", {
		get () {
			return getLuminance(this);
		},
		set (value) {
			setLuminance(this, value);
		}
	});
}

var luminance = /*#__PURE__*/Object.freeze({
	__proto__: null,
	getLuminance: getLuminance,
	setLuminance: setLuminance,
	register: register$2
});

// WCAG 2.0 contrast https://www.w3.org/TR/WCAG20-TECHS/G18.html

function contrastWCAG21 (color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);

	let Y1 = Math.max(getLuminance(color1), 0);
	let Y2 = Math.max(getLuminance(color2), 0);

	if (Y2 > Y1) {
		[Y1, Y2] = [Y2, Y1];
	}

	return (Y1 + .05) / (Y2 + .05);
}

// APCA 0.0.98G

// exponents
const normBG = 0.56;
const normTXT = 0.57;
const revTXT = 0.62;
const revBG = 0.65;

// clamps
const blkThrs = 0.022;
const blkClmp = 1.414;
const loClip = 0.1;
const deltaYmin = 0.0005;

// scalers
// see https://github.com/w3c/silver/issues/645
const scaleBoW = 1.14;
const loBoWoffset = 0.027;
const scaleWoB= 1.14;

function fclamp (Y) {
	if (Y >= blkThrs) {
		return Y;
	}
	return Y + (blkThrs - Y) ** blkClmp;
}

function linearize (val) {
	let sign = val < 0? -1 : 1;
	let abs = Math.abs(val);
	return sign * Math.pow(abs, 2.4);
}

// Not symmetric, requires a foreground (text) color, and a background color
function contrastAPCA (background, foreground) {
	foreground = getColor(foreground);
	background = getColor(background);

	let S;
	let C;
	let Sapc;

	// Myndex as-published, assumes sRGB inputs
	let R, G, B;

	foreground = to(foreground, "srgb");
	// Should these be clamped to in-gamut values?

	// Calculates "screen luminance" with non-standard simple gamma EOTF
	// weights should be from CSS Color 4, not the ones here which are via Myndex and copied from Lindbloom
	[R, G, B] = foreground.coords;
	let lumTxt = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;

	background = to(background, "srgb");
	[R, G, B] = background.coords;
	let lumBg = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;

	// toe clamping of very dark values to account for flare
	let Ytxt = fclamp(lumTxt);
	let Ybg = fclamp(lumBg);

	// are we "Black on White" (dark on light), or light on dark?
	let BoW = Ybg > Ytxt;

	// why is this a delta, when Y is not perceptually uniform?
	// Answer: it is a noise gate, see
	// https://github.com/LeaVerou/color.js/issues/208
	if (Math.abs(Ybg - Ytxt) < deltaYmin) {
		C = 0;
	}
	else {
		if (BoW) {
			// dark text on light background
			S = Ybg ** normBG - Ytxt ** normTXT;
			C = S * scaleBoW;
		}
		else {
			// light text on dark background
			S = Ybg ** revBG - Ytxt ** revTXT;
			C = S * scaleWoB;
		}
	}
	if (Math.abs(C) < loClip) {
		Sapc = 0;
	}
	else if (C > 0) {
		// not clear whether Woffset is loBoWoffset or loWoBoffset
		// but they have the same value
		Sapc = C - loBoWoffset;
	}
	else {
		Sapc = C + loBoWoffset;
	}

	return Sapc * 100;
}

// Michelson  luminance contrast

function contrastMichelson (color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);

	let Y1 = Math.max(getLuminance(color1), 0);
	let Y2 = Math.max(getLuminance(color2), 0);

	if (Y2 > Y1) {
		[Y1, Y2] = [Y2, Y1];
	}

	let denom = (Y1 + Y2);
	return denom === 0 ? 0 : (Y1 - Y2) / denom;
}

// Weber luminance contrast

// the darkest sRGB color above black is #000001 and this produces
// a plain Weber contrast of ~45647.
// So, setting the divide-by-zero result at 50000 is a reasonable
// max clamp for the plain Weber
const max = 50000;

function contrastWeber (color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);

	let Y1 = Math.max(getLuminance(color1), 0);
	let Y2 = Math.max(getLuminance(color2), 0);

	if (Y2 > Y1) {
		[Y1, Y2] = [Y2, Y1];
	}

	return Y2 === 0 ? max : (Y1 - Y2) / Y2;
}

// CIE Lightness difference, as used by Google Material Design

function contrastLstar (color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);

	let L1 = get(color1, [lab, "l"]);
	let L2 = get(color2, [lab, "l"]);

	return Math.abs(L1 - L2);
}

// κ * ε  = 2^3 = 8
const ε$1 = 216/24389;  // 6^3/29^3 == (24/116)^3
const ε3 = 24/116;
const κ = 24389/27;   // 29^3/3^3

let white = WHITES.D65;

var lab_d65 = new ColorSpace({
	id: "lab-d65",
	name: "Lab D65",
	coords: {
		l: {
			refRange: [0, 100],
			name: "L"
		},
		a: {
			refRange: [-125, 125]
		},
		b: {
			refRange: [-125, 125]
		}
	},

	// Assuming XYZ is relative to D65, convert to CIE Lab
	// from CIE standard, which now defines these as a rational fraction
	white,

	base: XYZ_D65,
	// Convert D65-adapted XYZ to Lab
	//  CIE 15.3:2004 section 8.2.1.1
	fromBase (XYZ) {
		// compute xyz, which is XYZ scaled relative to reference white
		let xyz = XYZ.map((value, i) => value / white[i]);

		// now compute f
		let f = xyz.map(value => value > ε$1 ? Math.cbrt(value) : (κ * value + 16)/116);

		return [
			(116 * f[1]) - 16, 	 // L
			500 * (f[0] - f[1]), // a
			200 * (f[1] - f[2])  // b
		];
	},
	// Convert Lab to D65-adapted XYZ
	// Same result as CIE 15.3:2004 Appendix D although the derivation is different
	// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
	toBase (Lab) {
		// compute f, starting with the luminance-related term
		let f = [];
		f[1] = (Lab[0] + 16)/116;
		f[0] = Lab[1]/500 + f[1];
		f[2] = f[1] - Lab[2]/200;

		// compute xyz
		let xyz = [
			f[0]   > ε3  ?  Math.pow(f[0], 3)            : (116*f[0]-16)/κ,
			Lab[0] > 8   ?  Math.pow((Lab[0]+16)/116, 3) : Lab[0]/κ,
			f[2]   > ε3  ?  Math.pow(f[2], 3)            : (116*f[2]-16)/κ
		];

		// Compute XYZ by scaling xyz by reference white
		return xyz.map((value, i) => value * white[i]);
	},

	formats: {
		"lab-d65": {
			coords: ["<number> | <percentage>", "<number>", "<number>"],
		}
	}
});

// Delta Phi Star perceptual lightness contrast

const phi = Math.pow(5, 0.5) * 0.5 + 0.5; // Math.phi can be used if Math.js

function contrastDeltaPhi (color1, color2) {
	color1 = getColor(color1);
	color2 = getColor(color2);

	let Lstr1 = get(color1, [lab_d65, "l"]);
	let Lstr2 = get(color2, [lab_d65, "l"]);

	let deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));

	let contrast = Math.pow(deltaPhiStar, (1 / phi)) * Math.SQRT2 - 40;

	return (contrast < 7.5) ? 0.0 : contrast ;
}

var contrastMethods = /*#__PURE__*/Object.freeze({
	__proto__: null,
	contrastWCAG21: contrastWCAG21,
	contrastAPCA: contrastAPCA,
	contrastMichelson: contrastMichelson,
	contrastWeber: contrastWeber,
	contrastLstar: contrastLstar,
	contrastDeltaPhi: contrastDeltaPhi
});

function contrast (background, foreground, o = {}) {
	if (isString(o)) {
		o = {algorithm: o};
	}

	let {algorithm, ...rest} = o;

	if (!algorithm) {
		let algorithms = Object.keys(contrastMethods).map(a => a.replace(/^contrast/, "")).join(", ");
		throw new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);
	}

	background = getColor(background);
	foreground = getColor(foreground);

	for (let a in contrastMethods) {
		if ("contrast" + algorithm.toLowerCase() === a.toLowerCase()) {
			return contrastMethods[a](background, foreground, rest);
		}
	}

	throw new TypeError(`Unknown contrast algorithm: ${algorithm}`);
}

// Chromaticity coordinates
function uv (color) {
	let [X, Y, Z] = getAll(color, XYZ_D65);
	let denom = X + 15 * Y + 3 * Z;
	return [4 * X / denom, 9 * Y / denom];
}

function xy (color) {
	let [X, Y, Z] = getAll(color, XYZ_D65);
	let  sum = X + Y + Z;
	return [X / sum, Y / sum];
}

function register$1 (Color) {
	// no setters, as lightness information is lost
	// when converting color to chromaticity
	Object.defineProperty(Color.prototype, "uv", {
		get () {
			return uv(this);
		}
	});

	Object.defineProperty(Color.prototype, "xy", {
		get () {
			return xy(this);
		}
	});
}

var chromaticity = /*#__PURE__*/Object.freeze({
	__proto__: null,
	uv: uv,
	xy: xy,
	register: register$1
});

function deltaE76 (color, sample) {
	return distance(color, sample, "lab");
}

// More accurate color-difference formulae
// than the simple 1976 Euclidean distance in Lab

// CMC by the Color Measurement Committee of the
// Bradford Society of Dyeists and Colorsts, 1994.
// Uses LCH rather than Lab,
// with different weights for L, C and H differences
// A nice increase in accuracy for modest increase in complexity
const π = Math.PI;
const d2r = π / 180;

function deltaECMC (color, sample, {l = 2, c = 1} = {}) {
	// Given this color as the reference
	// and a sample,
	// calculate deltaE CMC.

	// This implementation assumes the parametric
	// weighting factors l:c are 2:1
	// which is typical for non-textile uses.

	let [L1, a1, b1] = lab.from(color);
	let [, C1, H1] = lch.from(lab, [L1, a1, b1]);
	let [L2, a2, b2] = lab.from(sample);
	let C2 = lch.from(lab, [L2, a2, b2])[1];

	// let [L1, a1, b1] = color.getAll(lab);
	// let C1 = color.get("lch.c");
	// let H1 = color.get("lch.h");
	// let [L2, a2, b2] = sample.getAll(lab);
	// let C2 = sample.get("lch.c");

	// Check for negative Chroma,
	// which might happen through
	// direct user input of LCH values

	if (C1 < 0) {
		C1 = 0;
	}
	if (C2 < 0) {
		C2 = 0;
	}

	// we don't need H2 as ΔH is calculated from Δa, Δb and ΔC

	// Lightness and Chroma differences
	// These are (color - sample), unlike deltaE2000
	let ΔL = L1 - L2;
	let ΔC = C1 - C2;

	let Δa = a1 - a2;
	let Δb = b1 - b2;

	// weighted Hue difference, less for larger Chroma difference

	let H2 = (Δa ** 2) + (Δb ** 2) - (ΔC ** 2);
	// due to roundoff error it is possible that, for zero a and b,
	// ΔC > Δa + Δb is 0, resulting in attempting
	// to take the square root of a negative number

	// trying instead the equation from Industrial Color Physics
	// By Georg A. Klein

	// let ΔH = ((a1 * b2) - (a2 * b1)) / Math.sqrt(0.5 * ((C2 * C1) + (a2 * a1) + (b2 * b1)));
	// console.log({ΔH});
	// This gives the same result to 12 decimal places
	// except it sometimes NaNs when trying to root a negative number

	// let ΔH = Math.sqrt(H2); we never actually use the root, it gets squared again!!

	// positional corrections to the lack of uniformity of CIELAB
	// These are all trying to make JND ellipsoids more like spheres

	// SL Lightness crispening factor, depends entirely on L1 not L2
	let SL = 0.511;	// linear portion of the Y to L transfer function
	if (L1 >= 16) {	// cubic portion
		SL = (0.040975 * L1) / (1 + 0.01765 * L1);
	}

	// SC Chroma factor
	let SC = ((0.0638 * C1) / (1 + 0.0131 * C1)) + 0.638;

	// Cross term T for blue non-linearity
	let T;
	if ( Number.isNaN(H1)) {
		H1 = 0;
	}

	if (H1 >= 164 && H1 <= 345) {
		T = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));
	}
	else {
		T = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));
	}
	// console.log({T});

	// SH Hue factor also depends on C1,
	let C4 = Math.pow(C1, 4);
	let F = Math.sqrt(C4 / (C4 + 1900));
	let SH = SC * ((F * T) + 1 - F);

	// Finally calculate the deltaE, term by term as root sume of squares
	let dE = (ΔL / (l * SL)) ** 2;
	dE += (ΔC / (c * SC)) ** 2;
	dE += (H2 / (SH ** 2));
	// dE += (ΔH / SH)  ** 2;
	return Math.sqrt(dE);
	// Yay!!!
}

const Yw$1 = 203;	// absolute luminance of media white

var XYZ_Abs_D65 = new ColorSpace({
// Absolute CIE XYZ, with a D65 whitepoint,
// as used in most HDR colorspaces as a starting point.
// SDR spaces are converted per BT.2048
// so that diffuse, media white is 203 cd/m²
	id: "xyz-abs-d65",
	name: "Absolute XYZ D65",
	coords: {
		x: {
			refRange: [0, 9504.7],
			name: "Xa",
		},
		y: {
			refRange: [0, 10000],
			name: "Ya",
		},
		z: {
			refRange: [0, 10888.3],
			name: "Za",
		}
	},

	base: XYZ_D65,
	fromBase (XYZ) {
		// Make XYZ absolute, not relative to media white
		// Maximum luminance in PQ is 10,000 cd/m²
		// Relative XYZ has Y=1 for media white
		return XYZ.map (v => Math.max(v * Yw$1, 0));
	},
	toBase (AbsXYZ) {
		// Convert to media-white relative XYZ
		return AbsXYZ.map(v => Math.max(v / Yw$1, 0));
	}
});

const b$1 = 1.15;
const g = 0.66;
const n$1 = 2610 / (2 ** 14);
const ninv$1 = (2 ** 14) / 2610;
const c1$2 = 3424 / (2 ** 12);
const c2$2 = 2413 / (2 ** 7);
const c3$2 = 2392 / (2 ** 7);
const p = 1.7 * 2523 / (2 ** 5);
const pinv = (2 ** 5) / (1.7 * 2523);
const d = -0.56;
const d0 = 1.6295499532821566E-11;

const XYZtoCone_M = [
	[  0.41478972, 0.579999,  0.0146480 ],
	[ -0.2015100,  1.120649,  0.0531008 ],
	[ -0.0166008,  0.264800,  0.6684799 ]
];
// XYZtoCone_M inverted
const ConetoXYZ_M = [
	[  1.9242264357876067,  -1.0047923125953657,  0.037651404030618   ],
	[  0.35031676209499907,  0.7264811939316552, -0.06538442294808501 ],
	[ -0.09098281098284752, -0.3127282905230739,  1.5227665613052603  ]
];
const ConetoIab_M = [
	[  0.5,       0.5,       0        ],
	[  3.524000, -4.066708,  0.542708 ],
	[  0.199076,  1.096799, -1.295875 ]
];
// ConetoIab_M inverted
const IabtoCone_M = [
	[ 1,                   0.1386050432715393,   0.05804731615611886 ],
	[ 0.9999999999999999, -0.1386050432715393,  -0.05804731615611886 ],
	[ 0.9999999999999998, -0.09601924202631895, -0.8118918960560388  ]
];

var Jzazbz = new ColorSpace({
	id: "jzazbz",
	name: "Jzazbz",
	coords: {
		jz: {
			refRange: [0, 1],
			name: "Jz",
		},
		az: {
			refRange: [-0.5, 0.5],
		},
		bz: {
			refRange: [-0.5, 0.5],
		}
	},

	base: XYZ_Abs_D65,
	fromBase (XYZ) {
		// First make XYZ absolute, not relative to media white
		// Maximum luminance in PQ is 10,000 cd/m²
		// Relative XYZ has Y=1 for media white
		// BT.2048 says media white Y=203 at PQ 58

		let [ Xa, Ya, Za ] = XYZ;

		// modify X and Y
		let Xm = (b$1 * Xa) - ((b$1 - 1) * Za);
		let Ym = (g * Ya) - ((g - 1) * Xa);

		// move to LMS cone domain
		let LMS = multiplyMatrices(XYZtoCone_M, [ Xm, Ym, Za ]);

		// PQ-encode LMS
		let PQLMS = LMS.map (function (val) {
			let num = c1$2 + (c2$2 * ((val / 10000) ** n$1));
			let denom = 1 + (c3$2 * ((val / 10000) ** n$1));

			return (num / denom)  ** p;
		});

		// almost there, calculate Iz az bz
		let [ Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);
		// console.log({Iz, az, bz});

		let Jz = ((1 + d) * Iz) / (1 + (d * Iz)) - d0;
		return [Jz, az, bz];
	},
	toBase (Jzazbz) {
		let [Jz, az, bz] = Jzazbz;
		let Iz = (Jz + d0) / (1 + d - d * (Jz + d0));

		// bring into LMS cone domain
		let PQLMS = multiplyMatrices(IabtoCone_M, [ Iz, az, bz ]);

		// convert from PQ-coded to linear-light
		let LMS = PQLMS.map(function (val) {
			let num = (c1$2 - (val ** pinv));
			let denom = (c3$2 * (val ** pinv)) - c2$2;
			let x = 10000 * ((num / denom) ** ninv$1);

			return (x); 	// luminance relative to diffuse white, [0, 70 or so].
		});

		// modified abs XYZ
		let [ Xm, Ym, Za ] = multiplyMatrices(ConetoXYZ_M, LMS);

		// restore standard D50 relative XYZ, relative to media white
		let Xa = (Xm + ((b$1 -1) * Za)) / b$1;
		let Ya = (Ym + ((g -1) * Xa)) / g;
		return [ Xa, Ya, Za ];
	},

	formats: {
		// https://drafts.csswg.org/css-color-hdr/#Jzazbz
		"color": {}
	}
});

var jzczhz = new ColorSpace({
	id: "jzczhz",
	name: "JzCzHz",
	coords: {
		jz: {
			refRange: [0, 1],
			name: "Jz",
		},
		cz: {
			refRange: [0, 1],
			name: "Chroma",
		},
		hz: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue",
		}
	},

	base: Jzazbz,
	fromBase (jzazbz) {
		// Convert to polar form
		let [Jz, az, bz] = jzazbz;
		let hue;
		const ε = 0.0002; // chromatic components much smaller than a,b

		if (Math.abs(az) < ε && Math.abs(bz) < ε) {
			hue = NaN;
		}
		else {
			hue = Math.atan2(bz, az) * 180 / Math.PI;
		}

		return [
			Jz, // Jz is still Jz
			Math.sqrt(az ** 2 + bz ** 2), // Chroma
			constrain(hue) // Hue, in degrees [0 to 360)
		];
	},
	toBase (jzczhz) {
		// Convert from polar form
		// debugger;
		return [
			jzczhz[0], // Jz is still Jz
			jzczhz[1] * Math.cos(jzczhz[2] * Math.PI / 180), // az
			jzczhz[1] * Math.sin(jzczhz[2] * Math.PI / 180)  // bz
		];
	},
	formats: {
		color: {}
	},
});

// More accurate color-difference formulae
// than the simple 1976 Euclidean distance in Lab

// Uses JzCzHz, which has improved perceptual uniformity
// and thus a simple Euclidean root-sum of ΔL² ΔC² ΔH²
// gives good results.

function deltaEJz (color, sample) {
	// Given this color as the reference
	// and a sample,
	// calculate deltaE in JzCzHz.
	let [Jz1, Cz1, Hz1] = jzczhz.from(color);
	let [Jz2, Cz2, Hz2] = jzczhz.from(sample);

	// Lightness and Chroma differences
	// sign does not matter as they are squared.
	let ΔJ = Jz1 - Jz2;
	let ΔC = Cz1 - Cz2;

	// length of chord for ΔH
	if ((Number.isNaN(Hz1)) && (Number.isNaN(Hz2))) {
		// both undefined hues
		Hz1 = 0;
		Hz2 = 0;
	}
	else if (Number.isNaN(Hz1)) {
		// one undefined, set to the defined hue
		Hz1 = Hz2;
	}
	else if (Number.isNaN(Hz2)) {
		Hz2 = Hz1;
	}

	let Δh = Hz1 - Hz2;
	let ΔH = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin((Δh / 2) * (Math.PI / 180));

	return Math.sqrt(ΔJ ** 2 + ΔC ** 2 + ΔH ** 2);
}

const c1$1 = 3424 / 4096;
const c2$1 = 2413 / 128;
const c3$1 = 2392 / 128;
const m1 = 2610 / 16384;
const m2 = 2523 / 32;
const im1 = 16384 / 2610;
const im2 = 32 / 2523;

// The matrix below includes the 4% crosstalk components
// and is from the Dolby "What is ICtCp" paper"
const XYZtoLMS_M$1 = [
	[ 0.3592,  0.6976, -0.0358],
	[-0.1922,  1.1004,  0.0755],
	[ 0.0070,  0.0749,  0.8434]
];
// linear-light Rec.2020 to LMS, again with crosstalk
// rational terms from Jan Fröhlich,
// Encoding High Dynamic Range andWide Color Gamut Imagery, p.97
// and ITU-R BT.2124-0 p.2
/*
const Rec2020toLMS_M = [
	[ 1688 / 4096,  2146 / 4096,   262 / 4096 ],
	[  683 / 4096,  2951 / 4096,   462 / 4096 ],
	[   99 / 4096,   309 / 4096,  3688 / 4096 ]
];
*/
// this includes the Ebner LMS coefficients,
// the rotation, and the scaling to [-0.5,0.5] range
// rational terms from Fröhlich p.97
// and ITU-R BT.2124-0 pp.2-3
const LMStoIPT_M = [
	[  2048 / 4096,   2048 / 4096,       0      ],
	[  6610 / 4096, -13613 / 4096,  7003 / 4096 ],
	[ 17933 / 4096, -17390 / 4096,  -543 / 4096 ]
];

// inverted matrices, calculated from the above
const IPTtoLMS_M = [
	[0.99998889656284013833, 0.00860505014728705821,  0.1110343715986164786 ],
	[1.0000111034371598616, -0.00860505014728705821, -0.1110343715986164786 ],
	[1.000032063391005412,   0.56004913547279000113, -0.32063391005412026469],
];
/*
const LMStoRec2020_M = [
	[ 3.4375568932814012112,   -2.5072112125095058195,   0.069654319228104608382],
	[-0.79142868665644156125,   1.9838372198740089874,  -0.19240853321756742626 ],
	[-0.025646662911506476363, -0.099240248643945566751, 1.1248869115554520431  ]
];
*/
const LMStoXYZ_M$1 = [
	[ 2.0701800566956135096,   -1.3264568761030210255,    0.20661600684785517081 ],
	[ 0.36498825003265747974,   0.68046736285223514102,  -0.045421753075853231409],
	[-0.049595542238932107896, -0.049421161186757487412,  1.1879959417328034394  ]
];

// Only the PQ form of ICtCp is implemented here. There is also an HLG form.
// from Dolby, "WHAT IS ICTCP?"
// https://professional.dolby.com/siteassets/pdfs/ictcp_dolbywhitepaper_v071.pdf
// and
// Dolby, "Perceptual Color Volume
// Measuring the Distinguishable Colors of HDR and WCG Displays"
// https://professional.dolby.com/siteassets/pdfs/dolby-vision-measuring-perceptual-color-volume-v7.1.pdf
var ictcp = new ColorSpace({
	id: "ictcp",
	name: "ICTCP",
	// From BT.2100-2 page 7:
	// During production, signal values are expected to exceed the
	// range E′ = [0.0 : 1.0]. This provides processing headroom and avoids
	// signal degradation during cascaded processing. Such values of E′,
	// below 0.0 or exceeding 1.0, should not be clipped during production
	// and exchange.
	// Values below 0.0 should not be clipped in reference displays (even
	// though they represent “negative” light) to allow the black level of
	// the signal (LB) to be properly set using test signals known as “PLUGE”
	coords: {
		i: {
			refRange: [0, 1],	// Constant luminance,
			name: "I"
		},
		ct: {
			refRange: [-0.5, 0.5],	// Full BT.2020 gamut in range [-0.5, 0.5]
			name: "CT"
		},
		cp: {
			refRange: [-0.5, 0.5],
			name: "CP"
		}
	},

	base: XYZ_Abs_D65,
	fromBase (XYZ) {
		// move to LMS cone domain
		let LMS = multiplyMatrices(XYZtoLMS_M$1, XYZ);

		return LMStoICtCp(LMS);
	},
	toBase (ICtCp) {
		let LMS = ICtCptoLMS(ICtCp);

		return multiplyMatrices(LMStoXYZ_M$1, LMS);
	},
	formats: {
		color: {}
	},
});

function LMStoICtCp (LMS) {
	// apply the PQ EOTF
	// we can't ever be dividing by zero because of the "1 +" in the denominator
	let PQLMS = LMS.map (function (val) {
		let num = c1$1 + (c2$1 * ((val / 10000) ** m1));
		let denom = 1 + (c3$1 * ((val / 10000) ** m1));

		return (num / denom)  ** m2;
	});

	// LMS to IPT, with rotation for Y'C'bC'r compatibility
	return multiplyMatrices(LMStoIPT_M, PQLMS);
}

function ICtCptoLMS (ICtCp) {
	let PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);

	// From BT.2124-0 Annex 2 Conversion 3
	let LMS = PQLMS.map (function (val) {
		let num  = Math.max((val ** im2) - c1$1, 0);
		let denom = (c2$1 - (c3$1 * (val ** im2)));
		return 10000 * ((num / denom) ** im1);
	});

	return LMS;
}

// Delta E in ICtCp space,
// which the ITU calls Delta E ITP, which is shorter
// formulae from ITU Rec. ITU-R BT.2124-0

function deltaEITP (color, sample) {
	// Given this color as the reference
	// and a sample,
	// calculate deltaE in ICtCp
	// which is simply the Euclidean distance

	let [ I1, T1, P1 ] = ictcp.from(color);
	let [ I2, T2, P2 ] = ictcp.from(sample);

	// the 0.25 factor is to undo the encoding scaling in Ct
	// the 720 is so that 1 deltaE = 1 JND
	// per  ITU-R BT.2124-0 p.3

	return 720 * Math.sqrt((I1 - I2) ** 2 + (0.25 * (T1 -T2) ** 2) + (P1 - P2) ** 2);
}

// Recalculated for consistent reference white
// see https://github.com/w3c/csswg-drafts/issues/6642#issuecomment-943521484
const XYZtoLMS_M = [
	[ 0.8190224432164319,    0.3619062562801221,   -0.12887378261216414 ],
	[ 0.0329836671980271,    0.9292868468965546,     0.03614466816999844 ],
	[ 0.048177199566046255,  0.26423952494422764,    0.6335478258136937  ]
];
// inverse of XYZtoLMS_M
const LMStoXYZ_M = [
	[  1.2268798733741557,  -0.5578149965554813,   0.28139105017721583],
	[ -0.04057576262431372,  1.1122868293970594,  -0.07171106666151701],
	[ -0.07637294974672142, -0.4214933239627914,   1.5869240244272418 ]
];
const LMStoLab_M = [
	[  0.2104542553,   0.7936177850,  -0.0040720468 ],
	[  1.9779984951,  -2.4285922050,   0.4505937099 ],
	[  0.0259040371,   0.7827717662,  -0.8086757660 ]
];
// LMStoIab_M inverted
const LabtoLMS_M = [
	[ 0.99999999845051981432,  0.39633779217376785678,   0.21580375806075880339  ],
	[ 1.0000000088817607767,  -0.1055613423236563494,   -0.063854174771705903402 ],
	[ 1.0000000546724109177,  -0.089484182094965759684, -1.2914855378640917399   ]
];

var OKLab = new ColorSpace({
	id: "oklab",
    name: "OKLab",
    coords: {
		l: {
			refRange: [0, 1],
			name: "L"
		},
		a: {
			refRange: [-0.4, 0.4]
		},
		b: {
			refRange: [-0.4, 0.4]
		}
    },

	// Note that XYZ is relative to D65
  white: "D65",
	base: XYZ_D65,
	fromBase (XYZ) {
		// move to LMS cone domain
		let LMS = multiplyMatrices(XYZtoLMS_M, XYZ);

		// non-linearity
		let LMSg = LMS.map(val => Math.cbrt(val));

		return multiplyMatrices(LMStoLab_M, LMSg);

	},
	toBase (OKLab) {
		// move to LMS cone domain
		let LMSg = multiplyMatrices(LabtoLMS_M, OKLab);

		// restore linearity
		let LMS = LMSg.map(val => val ** 3);

		return multiplyMatrices(LMStoXYZ_M, LMS);
	},

	formats: {
		"oklab": {
			coords: ["<number> | <percentage>", "<number>", "<number>"],
		}
	}
});

// More accurate color-difference formulae

function deltaEOK (color, sample) {
	// Given this color as the reference
	// and a sample,
	// calculate deltaEOK, term by term as root sum of squares
	let [L1, a1, b1] = OKLab.from(color);
	let [L2, a2, b2] = OKLab.from(sample);
	let ΔL = L1 - L2;
	let Δa = a1 - a2;
	let Δb = b1 - b2;
	return Math.sqrt(ΔL ** 2 + Δa ** 2 + Δb ** 2);
}

var deltaEMethods = /*#__PURE__*/Object.freeze({
	__proto__: null,
	deltaE76: deltaE76,
	deltaECMC: deltaECMC,
	deltaE2000: deltaE2000,
	deltaEJz: deltaEJz,
	deltaEITP: deltaEITP,
	deltaEOK: deltaEOK
});

function deltaE (c1, c2, o = {}) {
	if (isString(o)) {
		o = {method: o};
	}

	let {method = defaults.deltaE, ...rest} = o;

	c1 = getColor(c1);
	c2 = getColor(c2);

	for (let m in deltaEMethods) {
		if ("deltae" + method.toLowerCase() === m.toLowerCase()) {
			return deltaEMethods[m](c1, c2, rest);
		}
	}

	throw new TypeError(`Unknown deltaE method: ${method}`);
}

function lighten$1 (color, amount = .25) {
	let space = ColorSpace.get("oklch", "lch");
	let lightness = [space, "l"];
	return set(color, lightness, l => l * (1 + amount));
}

function darken$1 (color, amount = .25) {
	let space = ColorSpace.get("oklch", "lch");
	let lightness = [space, "l"];
	return set(color, lightness, l => l * (1 - amount));
}

var variations = /*#__PURE__*/Object.freeze({
	__proto__: null,
	lighten: lighten$1,
	darken: darken$1
});

/**
 * Functions related to color interpolation
 */

/**
 * Return an intermediate color between two colors
 * Signatures: mix(c1, c2, p, options)
 *             mix(c1, c2, options)
 *             mix(color)
 * @param {Color | string} c1 The first color
 * @param {Color | string} [c2] The second color
 * @param {number} [p=.5] A 0-1 percentage where 0 is c1 and 1 is c2
 * @param {Object} [o={}]
 * @return {Color}
 */
function mix$1 (c1, c2, p = .5, o = {}) {
	[c1, c2] = [getColor(c1), getColor(c2)];

	if (type(p) === "object") {
		[p, o] = [.5, p];
	}

	let {space, outputSpace, premultiplied} = o;

	let r = range(c1, c2, {space, outputSpace, premultiplied});
	return r(p);
}

/**
 *
 * @param {Color | string | Function} c1 The first color or a range
 * @param {Color | string} [c2] The second color if c1 is not a range
 * @param {Object} [options={}]
 * @return {Color[]}
 */
function steps (c1, c2, options = {}) {
	let colorRange;

	if (isRange(c1)) {
		// Tweaking existing range
		[colorRange, options] = [c1, c2];
		[c1, c2] = colorRange.rangeArgs.colors;
	}

	let {
		maxDeltaE, deltaEMethod,
		steps = 2, maxSteps = 1000,
		...rangeOptions
	} = options;

	if (!colorRange) {
		[c1, c2] = [getColor(c1), getColor(c2)];
		colorRange = range(c1, c2, rangeOptions);
	}

	let totalDelta = deltaE(c1, c2);
	let actualSteps = maxDeltaE > 0? Math.max(steps, Math.ceil(totalDelta / maxDeltaE) + 1) : steps;
	let ret = [];

	if (maxSteps !== undefined) {
		actualSteps = Math.min(actualSteps, maxSteps);
	}

	if (actualSteps === 1) {
		ret = [{p: .5, color: colorRange(.5)}];
	}
	else {
		let step = 1 / (actualSteps - 1);
		ret = Array.from({length: actualSteps}, (_, i) => {
			let p = i * step;
			return {p, color: colorRange(p)};
		});
	}

	if (maxDeltaE > 0) {
		// Iterate over all stops and find max deltaE
		let maxDelta = ret.reduce((acc, cur, i) => {
			if (i === 0) {
				return 0;
			}

			let ΔΕ = deltaE(cur.color, ret[i - 1].color, deltaEMethod);
			return Math.max(acc, ΔΕ);
		}, 0);

		while (maxDelta > maxDeltaE) {
			// Insert intermediate stops and measure maxDelta again
			// We need to do this for all pairs, otherwise the midpoint shifts
			maxDelta = 0;

			for (let i = 1; (i < ret.length) && (ret.length < maxSteps); i++) {
				let prev = ret[i - 1];
				let cur = ret[i];

				let p = (cur.p + prev.p) / 2;
				let color = colorRange(p);
				maxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur.color));
				ret.splice(i, 0, {p, color: colorRange(p)});
				i++;
			}
		}
	}

	ret = ret.map(a => a.color);

	return ret;
}
/**
 * Interpolate to color2 and return a function that takes a 0-1 percentage
 * @param {Color | string | Function} color1 The first color or an existing range
 * @param {Color | string} [color2] If color1 is a color, this is the second color
 * @param {Object} [options={}]
 * @returns {Function} A function that takes a 0-1 percentage and returns a color
 */
function range (color1, color2, options = {}) {
	if (isRange(color1)) {
		// Tweaking existing range
		let [r, options] = [color1, color2];

		return range(...r.rangeArgs.colors, {...r.rangeArgs.options, ...options});
	}

	let {space, outputSpace, progression, premultiplied} = options;

	color1 = getColor(color1);
	color2 = getColor(color2);

	// Make sure we're working on copies of these colors
	color1 = clone(color1);
	color2 = clone(color2);

	let rangeArgs = {colors: [color1, color2], options};

	if (space) {
		space = ColorSpace.get(space);
	}
	else {
		space = ColorSpace.registry[defaults.interpolationSpace] || color1.space;
	}

	outputSpace = outputSpace? ColorSpace.get(outputSpace) : space;

	color1 = to(color1, space);
	color2 = to(color2, space);

	// Gamut map to avoid areas of flat color
	color1 = toGamut(color1);
	color2 = toGamut(color2);

	// Handle hue interpolation
	// See https://github.com/w3c/csswg-drafts/issues/4735#issuecomment-635741840
	if (space.coords.h && space.coords.h.type === "angle") {
		let arc = options.hue = options.hue || "shorter";

		let hue = [space, "h"];
		let [θ1, θ2] = [get(color1, hue), get(color2, hue)];
		[θ1, θ2] = adjust(arc, [θ1, θ2]);
		set(color1, hue, θ1);
		set(color2, hue, θ2);
	}

	if (premultiplied) {
		// not coping with polar spaces yet
		color1.coords = color1.coords.map(c => c * color1.alpha);
		color2.coords = color2.coords.map(c => c * color2.alpha);
	}

	return Object.assign(p => {
		p = progression? progression(p) : p;
		let coords = color1.coords.map((start, i) => {
			let end = color2.coords[i];
			return interpolate(start, end, p);
		});

		let alpha = interpolate(color1.alpha, color2.alpha, p);
		let ret = {space, coords, alpha};

		if (premultiplied) {
			// undo premultiplication
			ret.coords = ret.coords.map(c => c / alpha);
		}

		if (outputSpace !== space) {
			ret = to(ret, outputSpace);
		}

		return ret;
	}, {
		rangeArgs
	});
}
function isRange (val) {
	return type(val) === "function" && !!val.rangeArgs;
}
defaults.interpolationSpace = "lab";

function register (Color) {
	Color.defineFunction("mix", mix$1, {returns: "color"});
	Color.defineFunction("range", range, {returns: "function<color>"});
	Color.defineFunction("steps", steps, {returns: "array<color>"});
}

var interpolation = /*#__PURE__*/Object.freeze({
	__proto__: null,
	mix: mix$1,
	steps: steps,
	range: range,
	isRange: isRange,
	register: register
});

var HSL = new ColorSpace({
	id: "hsl",
	name: "HSL",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		s: {
			range: [0, 100],
			name: "Saturation"
		},
		l: {
			range: [0, 100],
			name: "Lightness"
		}
	},

	base: sRGB,

	// Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB
	fromBase: rgb => {
		let max = Math.max(...rgb);
		let min = Math.min(...rgb);
		let [r, g, b] = rgb;
		let [h, s, l] = [NaN, 0, (min + max)/2];
		let d = max - min;

		if (d !== 0) {
			s = (l === 0 || l === 1) ? 0 : (max - l) / Math.min(l, 1 - l);

			switch (max) {
				case r: h = (g - b) / d + (g < b ? 6 : 0); break;
				case g: h = (b - r) / d + 2; break;
				case b: h = (r - g) / d + 4;
			}

			h = h * 60;
		}

		return [h, s * 100, l * 100];
	},

	// Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative
	toBase: hsl => {
		let [h, s, l] = hsl;
		h = h % 360;

		if (h < 0) {
			h += 360;
		}

		s /= 100;
		l /= 100;

		function f (n) {
			let k = (n + h/30) % 12;
			let a = s * Math.min(l, 1 - l);
			return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));
		}

		return [f(0), f(8), f(4)];
	},

	formats: {
		"hsl": {
			toGamut: true,
			coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
		},
		"hsla": {
			coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
			commas: true,
			lastAlpha: true,
		}
	},
});

// The Hue, Whiteness Blackness (HWB) colorspace
// See https://drafts.csswg.org/css-color-4/#the-hwb-notation
// Note that, like HSL, calculations are done directly on
// gamma-corrected sRGB values rather than linearising them first.

var HSV = new ColorSpace({
	id: "hsv",
	name: "HSV",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		s: {
			range: [0, 100],
			name: "Saturation"
		},
		v: {
			range: [0, 100],
			name: "Value"
		}
	},

	base: HSL,
	// https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
	fromBase (hsl) {
		let [h, s, l] = hsl;
		s /= 100;
		l /= 100;

		let v = l + s * Math.min(l, 1 - l);

		return [
			h, // h is the same
			v === 0? 0 : 200 * (1 - l / v), // s
			100 * v
		];
	},
	// https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
	toBase (hsv) {
		let [h, s, v] = hsv;

		s /= 100;
		v /= 100;

		let l = v * (1 - s/2);

		return [
			h, // h is the same
			(l === 0 || l === 1)? 0 : ((v - l) / Math.min(l, 1 - l)) * 100,
			l * 100
		];
	},
	formats: {
		color: {
			toGamut: true,
		}
	}
});

// The Hue, Whiteness Blackness (HWB) colorspace
// See https://drafts.csswg.org/css-color-4/#the-hwb-notation
// Note that, like HSL, calculations are done directly on
// gamma-corrected sRGB values rather than linearising them first.

var hwb = new ColorSpace({
	id: "hwb",
	name: "HWB",
	coords: {
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		},
		w: {
			range: [0, 100],
			name: "Whiteness"
		},
		b: {
			range: [0, 100],
			name: "Blackness"
		}
	},

	base: HSV,
	fromBase (hsv) {
		let [h, s, v] = hsv;

		return [h, v * (100 - s) / 100, 100 - v];
	},
	toBase (hwb) {
		let [h, w, b] = hwb;

		// Now convert percentages to [0..1]
		w /= 100;
		b /= 100;

		// Achromatic check (white plus black >= 1)
		let sum = w + b;
		if (sum >= 1) {
			 let gray = w / sum;
			 return [h, 0, gray * 100];
		}

		let v = (1 - b);
		let s = (v === 0) ? 0 : 1 - w / v;
		return [h, s * 100, v * 100];
	},

	formats: {
		"hwb": {
			toGamut: true,
			coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
		}
	}
});

// convert an array of linear-light a98-rgb values to CIE XYZ
// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
// has greater numerical precision than section 4.3.5.3 of
// https://www.adobe.com/digitalimag/pdfs/AdobeRGB1998.pdf
// but the values below were calculated from first principles
// from the chromaticity coordinates of R G B W
const toXYZ_M$2 = [
	[ 0.5766690429101305,   0.1855582379065463,   0.1882286462349947  ],
	[ 0.29734497525053605,  0.6273635662554661,   0.07529145849399788 ],
	[ 0.02703136138641234,  0.07068885253582723,  0.9913375368376388  ]
];

const fromXYZ_M$2 = [
	[  2.0415879038107465,    -0.5650069742788596,   -0.34473135077832956 ],
	[ -0.9692436362808795,     1.8759675015077202,    0.04155505740717557 ],
	[  0.013444280632031142,  -0.11836239223101838,   1.0151749943912054  ]
];

var A98Linear = new RGBColorSpace({
	id: "a98rgb-linear",
	name: "Linear Adobe® 98 RGB compatible",
	white: "D65",
	toXYZ_M: toXYZ_M$2,
	fromXYZ_M: fromXYZ_M$2
});

var a98rgb = new RGBColorSpace({
	id: "a98rgb",
	name: "Adobe® 98 RGB compatible",
	base: A98Linear,
	toBase: RGB => RGB.map(val => Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),
	fromBase: RGB => RGB.map(val => Math.pow(Math.abs(val), 256 / 563) * Math.sign(val)),
	formats: {
		color: {
			id: "a98-rgb"
		}
	},
});

// convert an array of  prophoto-rgb values to CIE XYZ
// using  D50 (so no chromatic adaptation needed afterwards)
// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
const toXYZ_M$1 = [
	[ 0.7977604896723027,  0.13518583717574031,  0.0313493495815248     ],
	[ 0.2880711282292934,  0.7118432178101014,   0.00008565396060525902 ],
	[ 0.0,                 0.0,                  0.8251046025104601     ]
];

const fromXYZ_M$1 = [
	[  1.3457989731028281,  -0.25558010007997534,  -0.05110628506753401 ],
	[ -0.5446224939028347,   1.5082327413132781,    0.02053603239147973 ],
	[  0.0,                  0.0,                   1.2119675456389454  ]
];

var ProPhotoLinear = new RGBColorSpace({
	id: "prophoto-linear",
	name: "Linear ProPhoto",
	white: "D50",
	base: XYZ_D50,
	toXYZ_M: toXYZ_M$1,
	fromXYZ_M: fromXYZ_M$1
});

const Et = 1/512;
const Et2 = 16/512;

var prophoto = new RGBColorSpace({
	id: "prophoto",
	name: "ProPhoto",
	base: ProPhotoLinear,
	toBase (RGB) {
		// Transfer curve is gamma 1.8 with a small linear portion
		return RGB.map(v => v < Et2? v / 16 : v ** 1.8);
	},
	fromBase (RGB) {
		return RGB.map(v => v >= Et? v ** (1/1.8) : 16 * v);
	},
	formats: {
		color: {
			id: "prophoto-rgb"
		}
	},
});

var oklch = new ColorSpace({
	id: "oklch",
	name: "OKLCh",
	coords: {
		l: {
			refRange: [0, 1],
			name: "Lightness"
		},
		c: {
			refRange: [0, 0.4],
			name: "Chroma"
		},
		h: {
			refRange: [0, 360],
			type: "angle",
			name: "Hue"
		}
	},
	white: "D65",

	base: OKLab,
	fromBase (oklab) {
		// Convert to polar form
		let [L, a, b] = oklab;
		let h;
		const ε = 0.0002; // chromatic components much smaller than a,b

		if (Math.abs(a) < ε && Math.abs(b) < ε) {
			h = NaN;
		}
		else {
			h = Math.atan2(b, a) * 180 / Math.PI;
		}

		return [
			L, // OKLab L is still L
			Math.sqrt(a ** 2 + b ** 2), // Chroma
			constrain(h) // Hue, in degrees [0 to 360)
		];
	},
	// Convert from polar form
	toBase (oklch) {
		let [L, C, h] = oklch;
		let a, b;

		// check for NaN hue
		if (isNaN(h)) {
			a = 0;
			b = 0;
		}
		else {
			a = C * Math.cos(h * Math.PI / 180);
			b = C * Math.sin(h * Math.PI / 180);
		}

		return [ L, a, b ];
	},

	formats: {
		"oklch": {
			coords: ["<number> | <percentage>", "<number>", "<number> | <angle>"],
		}
	}
});

const Yw = 203;	// absolute luminance of media white, cd/m²
const n = 2610 / (2 ** 14);
const ninv = (2 ** 14) / 2610;
const m = 2523 / (2 ** 5);
const minv = (2 ** 5) / 2523;
const c1 = 3424 / (2 ** 12);
const c2 = 2413 / (2 ** 7);
const c3 = 2392 / (2 ** 7);

var rec2100Pq = new RGBColorSpace({
	id: "rec2100pq",
	name: "REC.2100-PQ",
	base: REC2020Linear,
	toBase (RGB) {
		// given PQ encoded component in range [0, 1]
		// return media-white relative linear-light
		return RGB.map(function (val) {
			let x = ((Math.max(((val ** minv) - c1), 0) / (c2 - (c3 * (val ** minv)))) ** ninv);
			return (x * 10000 / Yw); 	// luminance relative to diffuse white, [0, 70 or so].
		});
	},
	fromBase (RGB) {
		// given media-white relative linear-light
		// returnPQ encoded component in range [0, 1]
		return RGB.map(function (val) {
			let x = Math.max(val * Yw / 10000, 0); 	// absolute luminance of peak white is 10,000 cd/m².
			let num = (c1 + (c2 * (x ** n)));
			let denom = (1 + (c3 * (x ** n)));

			return ((num / denom)  ** m);
		});
	},
	formats: {
		color: {
			id: "rec2100-pq"
		},
	},
});

// FIXME see https://github.com/LeaVerou/color.js/issues/190

const a = 0.17883277;
const b = 0.28466892; // 1 - (4 * a)
const c = 0.55991073; // 0.5 - a * Math.log(4 *a)

const scale = 3.7743;	// Place 18% grey at HLG 0.38, so media white at 0.75

var rec2100Hlg = new RGBColorSpace({
	id: "rec2100hlg",
	cssid: "rec2100-hlg",
	name: "REC.2100-HLG",
	referred: "scene",

	base: REC2020Linear,
	toBase (RGB) {
		// given HLG encoded component in range [0, 1]
		// return media-white relative linear-light
		return RGB.map(function (val) {
			// first the HLG EOTF
			// ITU-R BT.2390-10 p.30 section
			// 6.3 The hybrid log-gamma electro-optical transfer function (EOTF)
			// Then scale by 3 so media white is 1.0
			if (val <= 0.5) {
				return (val ** 2) / 3 * scale;
			}
			return Math.exp(((val - c) / a) + b) / 12 * scale;
		});
	},
	fromBase (RGB) {
		// given media-white relative linear-light
		// where diffuse white is 1.0,
		// return HLG encoded component in range [0, 1]
		return RGB.map(function (val) {
			// first scale to put linear-light media white at 1/3
			val /= scale;
			// now the HLG OETF
			// ITU-R BT.2390-10 p.23
			// 6.1 The hybrid log-gamma opto-electronic transfer function (OETF)
			if (val <= 1/12) {
				return Math.sqrt( 3 * val);
			}
			return a * Math.log(12 * val - b) + c;
		});
	},
	formats: {
		color: {
			id: "rec2100-hlg"
		},
	},
});

const CATs = {};

hooks.add("chromatic-adaptation-start", env => {
	if (env.options.method) {
		env.M = adapt(env.W1, env.W2, env.options.method);
	}
});

hooks.add("chromatic-adaptation-end", env => {
	if (!env.M) {
		env.M = adapt(env.W1, env.W2, env.options.method);
	}
});

function defineCAT ({id, toCone_M, fromCone_M}) {
	// Use id, toCone_M, fromCone_M like variables
	CATs[id] = arguments[0];
}
function adapt (W1, W2, id = "Bradford") {
	// adapt from a source whitepoint or illuminant W1
	// to a destination whitepoint or illuminant W2,
	// using the given chromatic adaptation transform (CAT)
	// debugger;
	let method = CATs[id];

	let [ρs, γs, βs] = multiplyMatrices(method.toCone_M, W1);
	let [ρd, γd, βd] = multiplyMatrices(method.toCone_M, W2);

	// all practical illuminants have non-zero XYZ so no division by zero can occur below
	let scale = [
		[ρd/ρs,    0,      0      ],
		[0,        γd/γs,  0      ],
		[0,        0,      βd/βs  ]
	];
	// console.log({scale});

	let scaled_cone_M = multiplyMatrices(scale, method.toCone_M);
	let adapt_M	= multiplyMatrices(method.fromCone_M, scaled_cone_M);
	// console.log({scaled_cone_M, adapt_M});
	return adapt_M;
}
defineCAT({
	id: "von Kries",
	toCone_M: [
		[  0.4002400,  0.7076000, -0.0808100 ],
		[ -0.2263000,  1.1653200,  0.0457000 ],
		[  0.0000000,  0.0000000,  0.9182200 ]
	],
	fromCone_M: [
		[  1.8599364, -1.1293816,  0.2198974 ],
		[  0.3611914,  0.6388125, -0.0000064 ],
		[  0.0000000,  0.0000000,  1.0890636 ]
	]
});

defineCAT({
	id: "Bradford",
	// Convert an array of XYZ values in the range 0.0 - 1.0
	// to cone fundamentals
	toCone_M: [
		[  0.8951000,  0.2664000, -0.1614000 ],
		[ -0.7502000,  1.7135000,  0.0367000 ],
		[  0.0389000, -0.0685000,  1.0296000 ]
	],
	// and back
	fromCone_M: [
		[  0.9869929, -0.1470543,  0.1599627 ],
		[  0.4323053,  0.5183603,  0.0492912 ],
		[ -0.0085287,  0.0400428,  0.9684867 ]
	]
});

defineCAT({
	id: "CAT02",
	// with complete chromatic adaptation to W2, so D = 1.0
	toCone_M: [
		[  0.7328000,  0.4296000, -0.1624000 ],
		[ -0.7036000,  1.6975000,  0.0061000 ],
		[  0.0030000,  0.0136000,  0.9834000 ]
	],
	fromCone_M: [
		[  1.0961238, -0.2788690,  0.1827452 ],
		[  0.4543690,  0.4735332,  0.0720978 ],
		[ -0.0096276, -0.0056980,  1.0153256 ]
	]
});

defineCAT({
	id: "CAT16",
	toCone_M: [
		[  0.401288,  0.650173, -0.051461 ],
		[ -0.250268,  1.204414,  0.045854 ],
		[ -0.002079,  0.048952,  0.953127 ]
	],
	// the extra precision is needed to avoid roundtripping errors
	fromCone_M: [
		[  1.862067855087233e+0, -1.011254630531685e+0,   1.491867754444518e-1 ],
		[  3.875265432361372e-1,  6.214474419314753e-1,  -8.973985167612518e-3 ],
		[ -1.584149884933386e-2, -3.412293802851557e-2,   1.049964436877850e+0 ]
	]
});

Object.assign(WHITES, {
	// whitepoint values from ASTM E308-01 with 10nm spacing, 1931 2 degree observer
	// all normalized to Y (luminance) = 1.00000
	// Illuminant A is a tungsten electric light, giving a very warm, orange light.
	A:  [1.09850, 1.00000, 0.35585],

	// Illuminant C was an early approximation to daylight: illuminant A with a blue filter.
	C:   [0.98074, 1.000000, 1.18232],

	// The daylight series of illuminants simulate natural daylight.
	// The color temperature (in degrees Kelvin/100) ranges from
	// cool, overcast daylight (D50) to bright, direct sunlight (D65).
	D55: [0.95682, 1.00000, 0.92149],
	D75: [0.94972, 1.00000, 1.22638],

	// Equal-energy illuminant, used in two-stage CAT16
	E:   [1.00000, 1.00000, 1.00000],

	// The F series of illuminants represent fluorescent lights
	F2:  [0.99186, 1.00000, 0.67393],
	F7:  [0.95041, 1.00000, 1.08747],
	F11: [1.00962, 1.00000, 0.64350],
});

// The ACES whitepoint
// see TB-2018-001 Derivation of the ACES White Point CIE Chromaticity Coordinates
// also https://github.com/ampas/aces-dev/blob/master/documents/python/TB-2018-001/aces_wp.py
// Similar to D60
WHITES.ACES = [0.32168/0.33767, 1.00000, (1.00000 - 0.32168 - 0.33767)/0.33767];

// convert an array of linear-light ACEScc values to CIE XYZ
const toXYZ_M = [
	[  0.6624541811085053,   0.13400420645643313,  0.1561876870049078  ],
	[  0.27222871678091454,  0.6740817658111484,   0.05368951740793705 ],
	[ -0.005574649490394108, 0.004060733528982826, 1.0103391003129971  ]
];
const fromXYZ_M = [
	[  1.6410233796943257,   -0.32480329418479,    -0.23642469523761225  ],
	[ -0.6636628587229829,    1.6153315916573379,   0.016756347685530137 ],
	[  0.011721894328375376, -0.008284441996237409, 0.9883948585390215   ]
];

var ACEScg = new RGBColorSpace({
	id: "acescg",
	name: "ACEScg",

	// ACEScg – A scene-referred, linear-light encoding of ACES Data
	// https://docs.acescentral.com/specifications/acescg/
	// uses the AP1 primaries, see section 4.3.1 Color primaries
	coords: {
		r: {
			range: [0, 65504],
			name: "Red"
		},
		g: {
			range: [0, 65504],
			name: "Green"
		},
		b: {
			range: [0, 65504],
			name: "Blue"
		}
	},

	referred: "scene",

	white: WHITES.ACES,

	toXYZ_M,
	fromXYZ_M,

	formats: {
		color: {}
	},
});

// export default Color;

const ε = 2 ** -16;

// the smallest value which, in the 32bit IEEE 754 float encoding,
// decodes as a non-negative value
const ACES_min_nonzero = -0.35828683;

// brightest encoded value, decodes to 65504
const ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52; // 1.468

var acescc = new RGBColorSpace({
	id: "acescc",
	name: "ACEScc",
	// see S-2014-003 ACEScc – A Logarithmic Encoding of ACES Data
	// https://docs.acescentral.com/specifications/acescc/
	// uses the AP1 primaries, see section 4.3.1 Color primaries

	// Appendix A: "Very small ACES scene referred values below 7 1/4 stops
	// below 18% middle gray are encoded as negative ACEScc values.
	// These values should be preserved per the encoding in Section 4.4
	// so that all positive ACES values are maintained."
	coords: {
		r: {
			range: [ACES_min_nonzero, ACES_cc_max],
			name: "Red"
		},
		g: {
			range: [ACES_min_nonzero, ACES_cc_max],
			name: "Green"
		},
		b: {
			range: [ACES_min_nonzero, ACES_cc_max],
			name: "Blue"
		}
	},
	referred: "scene",

	base: ACEScg,
	// from section 4.4.2 Decoding Function
	toBase (RGB) {
		const low = (9.72 - 15) / 17.52; // -0.3014

		return RGB.map(function (val) {
			if (val <= low) {
				return (2 ** ((val * 17.52) - 9.72) - ε) * 2; // very low values, below -0.3014
			}
			else if (val < ACES_cc_max) {
				return 2 ** ((val * 17.52) - 9.72);
			}
			else { // val >= ACES_cc_max
				return 65504;
			}
		});
	},

	// Non-linear encoding function from S-2014-003, section 4.4.1 Encoding Function
	fromBase (RGB) {
		return RGB.map(function (val) {
			if (val <= 0) {
				return (Math.log2(ε) + 9.72) / 17.52; // -0.3584
			}
			else if (val < ε) {
				return  (Math.log2(ε + val * 0.5) + 9.72) / 17.52;
			}
			else { // val >= ε
				return  (Math.log2(val) + 9.72) / 17.52;
			}
		});
	},
	// encoded media white (rgb 1,1,1) => linear  [ 222.861, 222.861, 222.861 ]
	// encoded media black (rgb 0,0,0) => linear [ 0.0011857, 0.0011857, 0.0011857]
	formats: {
		color: {}
	}
});

var spaces = /*#__PURE__*/Object.freeze({
	__proto__: null,
	XYZ_D65: XYZ_D65,
	XYZ_D50: XYZ_D50,
	XYZ_ABS_D65: XYZ_Abs_D65,
	Lab_D65: lab_d65,
	Lab: lab,
	LCH: lch,
	sRGB_Linear: sRGBLinear,
	sRGB: sRGB,
	HSL: HSL,
	HWB: hwb,
	HSV: HSV,
	P3_Linear: P3Linear,
	P3: P3,
	A98RGB_Linear: A98Linear,
	A98RGB: a98rgb,
	ProPhoto_Linear: ProPhotoLinear,
	ProPhoto: prophoto,
	REC_2020_Linear: REC2020Linear,
	REC_2020: REC2020,
	OKLab: OKLab,
	OKLCH: oklch,
	Jzazbz: Jzazbz,
	JzCzHz: jzczhz,
	ICTCP: ictcp,
	REC_2100_PQ: rec2100Pq,
	REC_2100_HLG: rec2100Hlg,
	ACEScg: ACEScg,
	ACEScc: acescc
});

/**
 * Class that represents a color
 */
class Color {
	/**
	 * Creates an instance of Color.
	 * Signatures:
	 * - `new Color(stringToParse)`
	 * - `new Color(otherColor)`
	 * - `new Color({space, coords, alpha})`
	 * - `new Color(space, coords, alpha)`
	 * - `new Color(spaceId, coords, alpha)`
	 */
	constructor (...args) {
		let color;

		if (args.length === 1) {
			color = getColor(args[0]);
		}

		let space, coords, alpha;

		if (color) {
			space = color.space || color.spaceId;
			coords = color.coords;
			alpha = color.alpha;
		}
		else {
			// default signature new Color(ColorSpace, array [, alpha])
			[space, coords, alpha] = args;
		}

		this.#space = ColorSpace.get(space);
		this.coords = coords? coords.slice() : [0, 0, 0];
		this.alpha = alpha < 1? alpha : 1; // this also deals with NaN etc

		// Convert "NaN" to NaN
		for (let i = 0; i < this.coords.length; i++) {
			if (this.coords[i] === "NaN") {
				this.coords[i] = NaN;
			}
		}

		// Define getters and setters for each coordinate
		for (let id in this.#space.coords) {
			Object.defineProperty(this, id, {
				get: () => this.get(id),
				set: value => this.set(id, value)
			});
		}
	}

	#space;

	get space () {
		return this.#space;
	}

	get spaceId () {
		return this.#space.id;
	}

	clone () {
		return new Color(this.space, this.coords, this.alpha);
	}

	toJSON () {
		return {
			spaceId: this.spaceId,
			coords: this.coords,
			alpha: this.alpha
		};
	}

	display (...args) {
		let ret = display(this, ...args);

		// Convert color object to Color instance
		ret.color = new Color(ret.color);

		return ret;
	}

	/**
	 * Get a color from the argument passed
	 * Basically gets us the same result as new Color(color) but doesn't clone an existing color object
	 */
	static get (color, ...args) {
		if (color instanceof Color) {
			return color;
		}

		return new Color(color, ...args);
	}

	static defineFunction (name, code, o = code) {
		let {instance = true, returns} = o;

		let func = function (...args) {
			let ret = code(...args);

			if (returns === "color") {
				ret = Color.get(ret);
			}
			else if (returns === "function<color>") {
				let f = ret;
				ret = function (...args) {
					let ret = f(...args);
					return Color.get(ret);
				};
				// Copy any function metadata
				Object.assign(ret, f);
			}
			else if (returns === "array<color>") {
				ret = ret.map(c => Color.get(c));
			}

			return ret;
		};

		if (!(name in Color)) {
			Color[name] = func;
		}

		if (instance) {
			Color.prototype[name] = function (...args) {
				return func(this, ...args);
			};
		}
	}

	static defineFunctions (o) {
		for (let name in o) {
			Color.defineFunction(name, o[name], o[name]);
		}
	}

	static extend (exports) {
		if (exports.register) {
			exports.register(Color);
		}
		else {
			// No register method, just add the module's functions
			for (let name in exports) {
				Color.defineFunction(name, exports[name]);
			}
		}
	}
}
Color.defineFunctions({
	get,
	getAll,
	set,
	setAll,
	to,
	equals,
	inGamut,
	toGamut,
	distance,
	toString: serialize,
});

Object.assign(Color, {
	util,
	hooks,
	WHITES,
	Space: ColorSpace,
	spaces: ColorSpace.registry,
	parse,

	// Global defaults one may want to configure
	defaults
});

for (let key of Object.keys(spaces)) {
	ColorSpace.register(spaces[key]);
}

/**
 * This plugin defines getters and setters for color[spaceId]
 * e.g. color.lch on *any* color gives us the lch coords
 */

// Add space accessors to existing color spaces
for (let id in ColorSpace.registry) {
	addSpaceAccessors(id, ColorSpace.registry[id]);
}

// Add space accessors to color spaces not yet created
hooks.add("colorspace-init-end", space => {
	addSpaceAccessors(space.id, space);
	space.aliases?.forEach(alias => {
		addSpaceAccessors(alias, space);
	});
});

function addSpaceAccessors (id, space) {
	// Coordinates can be looked up by both id and name
	Object.keys(space.coords);
	Object.values(space.coords).map(c => c.name);


	let propId = id.replace(/-/g, "_");

	Object.defineProperty(Color.prototype, propId, {
		// Convert coords to coords in another colorspace and return them
		// Source colorspace: this.spaceId
		// Target colorspace: id
		get () {
			let ret = this.getAll(id);

			if (typeof Proxy === "undefined") {
				// If proxies are not supported, just return a static array
				return ret;
			}

			// Enable color.spaceId.coordName syntax
			return new Proxy(ret, {
				has: (obj, property) => {
					try {
						ColorSpace.resolveCoord([space, property]);
						return true;
					}
					catch (e) {}

					return Reflect.has(obj, property);
				},
				get: (obj, property, receiver) => {
					if (property && typeof property !== "symbol" && !(property in obj)) {
						let {index} = ColorSpace.resolveCoord([space, property]);

						if (index >= 0) {
							return obj[index];
						}
					}

					return Reflect.get(obj, property, receiver);
				},
				set: (obj, property, value, receiver) => {
					if (property && typeof property !== "symbol" && !(property in obj) || property >= 0) {
						let {index} = ColorSpace.resolveCoord([space, property]);

						if (index >= 0) {
							obj[index] = value;

							// Update color.coords
							this.setAll(id, obj);

							return true;
						}
					}

					return Reflect.set(obj, property, value, receiver);
				},
			});
		},
		// Convert coords in another colorspace to internal coords and set them
		// Target colorspace: this.spaceId
		// Source colorspace: id
		set (coords) {
			this.setAll(id, coords);
		},
		configurable: true,
		enumerable: true
	});
}

// Import all modules of Color.js

Color.extend(deltaEMethods);
Color.extend({deltaE});
Color.extend(variations);
Color.extend({contrast});
Color.extend(chromaticity);
Color.extend(luminance);
Color.extend(interpolation);
Color.extend(contrastMethods);

function transparentize(color, amount) {
    const _color = color;
    _color.alpha = Math.max(0, Math.min(1, Number(amount)));
    return _color;
}

function mix(color, amount, mixColor) {
    const mixValue = Math.max(0, Math.min(1, Number(amount)));
    return new Color(color.mix(mixColor, mixValue).toString());
}

function darken(color, colorSpace, amount) {
    switch (colorSpace) {
        case 'lch': {
            const lightness = color.lch.l;
            const difference = lightness;
            const newChroma = Math.max(0, color.lch.c - amount * color.lch.c);
            const newLightness = Math.max(0, lightness - difference * amount);
            color.set('lch.l', newLightness);
            color.set('lch.c', newChroma);
            return color;
        }
        case 'hsl': {
            const lightness = color.hsl.l;
            const difference = lightness;
            const newLightness = Math.max(0, lightness - difference * amount);
            color.set('hsl.l', newLightness);
            return color;
        }
        case 'p3': {
            const colorInP3 = color.to('p3');
            const newRed = Math.max(0, colorInP3.p3.r - amount * colorInP3.p3.r);
            const newGreen = Math.max(0, colorInP3.p3.g - amount * colorInP3.p3.g);
            const newBlue = Math.max(0, colorInP3.p3.b - amount * colorInP3.p3.b);
            colorInP3.set('p3.r', newRed);
            colorInP3.set('p3.g', newGreen);
            colorInP3.set('p3.b', newBlue);
            return colorInP3;
        }
        case 'srgb': {
            const newRed = Math.max(0, color.srgb.r - amount * color.srgb.r);
            const newGreen = Math.max(0, color.srgb.g - amount * color.srgb.g);
            const newBlue = Math.max(0, color.srgb.b - amount * color.srgb.b);
            color.set('srgb.r', newRed);
            color.set('srgb.g', newGreen);
            color.set('srgb.b', newBlue);
            return color;
        }
        default: {
            return color.darken(amount);
        }
    }
}

function lighten(color, colorSpace, amount) {
    switch (colorSpace) {
        case 'lch': {
            const lightness = color.lch.l;
            const difference = 100 - lightness;
            const newChroma = Math.max(0, color.lch.c - amount * color.lch.c);
            const newLightness = Math.min(100, lightness + difference * amount);
            color.set('lch.l', newLightness);
            color.set('lch.c', newChroma);
            return color;
        }
        case 'hsl': {
            const lightness = color.hsl.l;
            const difference = 100 - lightness;
            const newLightness = Math.min(100, lightness + difference * amount);
            color.set('hsl.l', newLightness);
            return color;
        }
        case 'p3': {
            const colorInP3 = color.to('p3');
            const newRed = Math.min(1, colorInP3.p3.r + amount * (1 - colorInP3.p3.r));
            const newGreen = Math.min(1, colorInP3.p3.g + amount * (1 - colorInP3.p3.g));
            const newBlue = Math.min(1, colorInP3.p3.b + amount * (1 - colorInP3.p3.b));
            colorInP3.set('p3.r', newRed);
            colorInP3.set('p3.g', newGreen);
            colorInP3.set('p3.b', newBlue);
            return colorInP3;
        }
        case 'srgb': {
            const newRed = Math.min(1, color.srgb.r + amount * (1 - color.srgb.r));
            const newGreen = Math.min(1, color.srgb.g + amount * (1 - color.srgb.g));
            const newBlue = Math.min(1, color.srgb.b + amount * (1 - color.srgb.b));
            color.set('srgb.r', newRed);
            color.set('srgb.g', newGreen);
            color.set('srgb.b', newBlue);
            return color;
        }
        default: {
            return color.lighten(amount);
        }
    }
}

function modifyColor(baseColor, modifier) {
    if (baseColor === undefined) {
        return baseColor;
    }
    const color = new Color(baseColor);
    let returnedColor = color;
    try {
        switch (modifier.type) {
            case 'lighten':
                returnedColor = lighten(color, modifier.space, Number(modifier.value));
                break;
            case 'darken':
                returnedColor = darken(color, modifier.space, Number(modifier.value));
                break;
            case 'mix':
                returnedColor = mix(color, Number(modifier.value), new Color(modifier.color));
                break;
            case 'alpha': {
                returnedColor = transparentize(color, Number(modifier.value));
                break;
            }
            default:
                returnedColor = color;
                break;
        }
        returnedColor = returnedColor.to(modifier.space);
        if (modifier.format && ['lch', 'srgb', 'p3', 'hsl'].includes(modifier.format)) {
            returnedColor = returnedColor.to(modifier.format);
        }
        return returnedColor.toString({
            inGamut: true,
            precision: 3,
            format: modifier.format,
        });
    }
    catch (e) {
        return baseColor;
    }
}

/**
 * Helper: Transforms color tokens with tokens studio color modifiers
 */
function transformColorModifiers(token) {
    /** @type {ColorModifier} */
    const modifier = token.$extensions['studio.tokens']?.modify;
    return modifyColor(token.value, modifier);
}

/**
 * Helper: Transforms letter spacing % to em
 */
function transformLetterSpacing(value) {
    if (value === undefined) {
        return value;
    }
    if (`${value}`.endsWith('%')) {
        const percentValue = value.slice(0, -1);
        return `${parseFloat(percentValue) / 100}em`;
    }
    return value;
}

/**
 * Helper: Transforms line-height % to unit-less decimal value
 * @example
 * 150% -> 1.5
 */
function transformLineHeight(value) {
    if (value === undefined) {
        return value;
    }
    if (`${value}`.endsWith('%')) {
        const percentValue = `${value}`.slice(0, -1);
        return parseFloat(percentValue) / 100;
    }
    return value;
}

/**
 * Helper: Transforms boxShadow object to shadow shorthand
 * This currently works fine if every value uses an alias,
 * but if any one of these use a raw value, it will not be transformed.
 */
function transformShadow(shadow) {
    if (shadow === undefined) {
        return shadow;
    }
    const { x, y, blur, spread, color } = shadow;
    return `${x} ${y} ${blur} ${spread} ${color}`;
}

/**
 * Helper: Transforms typography object to typography shorthand for CSS
 * This currently works fine if every value uses an alias, but if any one of these use a raw value, it will not be transformed.
 * If you'd like to output all typography values, you'd rather need to return the typography properties itself
 */
function transformTypographyForCSS(value) {
    if (value === undefined) {
        return value;
    }
    const { fontWeight, fontSize, lineHeight, fontFamily } = value;
    return `${transformFontWeights(fontWeight)} ${fontSize}/${lineHeight} ${fontFamily}`;
}

/**
 * Helper: Transforms typography object to typography shorthand for Jetpack Compose
 */
function transformTypographyForCompose(value) {
    if (value === undefined) {
        return value;
    }
    /**
     * Mapping between https://docs.tokens.studio/available-tokens/typography-tokens
     * and https://developer.android.com/reference/kotlin/androidx/compose/ui/text/TextStyle
     * Unsupported property:
     *  - paragraphSpacing
     */
    const textStylePropertiesMapping = {
        fontFamily: 'fontFamily',
        fontWeight: 'fontWeight',
        lineHeight: 'lineHeight',
        fontSize: 'fontSize',
        letterSpacing: 'letterSpacing',
        paragraphIndent: 'textIndent',
    };
    /**
     * Constructs a `TextStyle`, e.g.
     * TextStyle(
     *  fontSize = 16.dp
     * )
     */
    return `${Object.entries(value).reduce((acc, [propName, val]) => `${acc}${textStylePropertiesMapping[propName]
        ? `${propName === 'fontWeight' ? transformFontWeights(val) : val}\n`
        : ''}`, 'TextStyle(\n')})`;
}

/**
 * Helper: Maps the token description to a style dictionary comment attribute - this will be picked up by some Style Dictionary
 * formats and automatically output as code comments
 */
function mapDescriptionToComment(token) {
    // intentional mutation of the original object
    const _t = token;
    _t.comment = _t.description;
    return _t;
}

const isBrowser = typeof window === 'object';
/**
 * typecasting since this will need to work in browser environment, so we cannot
 * import style-dictionary as it depends on nodejs env
 */
async function registerTransforms(sd) {
    let _sd = sd;
    // NodeJS env and no passed SD? let's register on our installed SD
    // We're in ESM, but style-dictionary is CJS only, so we need module.createRequire
    if (!isBrowser && _sd === undefined) {
        const module = await import('module');
        const mod = module.default;
        const require$1 = mod.createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (document.currentScript && document.currentScript.src || new URL('index.cjs', document.baseURI).href)));
        _sd = require$1('style-dictionary');
    }
    _sd.registerTransform({
        name: 'ts/size/px',
        type: 'value',
        transitive: true,
        matcher: token => ['sizing', 'spacing', 'borderRadius', 'borderWidth', 'fontSizes', 'dimension'].includes(token.type),
        transformer: token => transformDimension(token.value),
    });
    _sd.registerTransform({
        name: 'ts/color/hexrgba',
        type: 'value',
        transitive: true,
        matcher: token => typeof token.value === 'string' && token.value.startsWith('rgba(#'),
        transformer: token => transformHEXRGBa(token.value),
    });
    _sd.registerTransform({
        name: 'ts/color/modifiers',
        type: 'value',
        transitive: true,
        matcher: token => token.type === 'color' && token.$extensions && token.$extensions['studio.tokens']?.modify,
        transformer: token => transformColorModifiers(token),
    });
    _sd.registerTransform({
        name: 'ts/shadow/shorthand',
        type: 'value',
        transitive: true,
        matcher: token => ['boxShadow'].includes(token.type),
        transformer: token => Array.isArray(token.original.value)
            ? token.original.value.map(single => transformShadow(single)).join(', ')
            : transformShadow(token.original.value),
    });
    _sd.registerTransform({
        name: 'ts/type/fontWeight',
        type: 'value',
        transitive: true,
        matcher: token => token.type === 'fontWeights',
        transformer: token => transformFontWeights(token.value),
    });
    _sd.registerTransform({
        name: 'ts/size/letterspacing',
        type: 'value',
        transitive: true,
        matcher: token => token.type === 'letterSpacing',
        transformer: token => transformLetterSpacing(token.value),
    });
    _sd.registerTransform({
        name: 'ts/size/lineheight',
        type: 'value',
        transitive: true,
        matcher: token => token.type === 'lineHeights',
        transformer: token => transformLineHeight(token.value),
    });
    _sd.registerTransform({
        name: 'ts/typography/css/shorthand',
        type: 'value',
        transitive: true,
        matcher: token => token.type === 'typography',
        transformer: token => transformTypographyForCSS(token.original.value),
    });
    _sd.registerTransform({
        name: 'ts/typography/compose/shorthand',
        type: 'value',
        transitive: true,
        matcher: token => token.type === 'typography',
        transformer: token => transformTypographyForCompose(token.original.value),
    });
    _sd.registerTransform({
        name: 'ts/resolveMath',
        type: 'value',
        transitive: true,
        matcher: token => typeof token.value === 'string',
        // Putting this in strings seems to be required
        transformer: token => `${checkAndEvaluateMath(token.value)}`,
    });
    _sd.registerTransform({
        name: 'ts/descriptionToComment',
        type: 'attribute',
        matcher: token => token.description,
        transformer: token => mapDescriptionToComment(token),
    });
    _sd.registerTransformGroup({
        name: 'tokens-studio',
        transforms: [
            'ts/descriptionToComment',
            'ts/resolveMath',
            'ts/size/px',
            'ts/size/letterspacing',
            'ts/size/lineheight',
            'ts/type/fontWeight',
            'ts/color/hexrgba',
            'ts/color/modifiers',
            'ts/typography/css/shorthand',
            'ts/shadow/shorthand',
            // by default we go with camel, as having no default will likely give the user
            // errors straight away. This can be overridden by manually passing an array of transforms
            // instead of this transformGroup, or by doing a name conversion in your custom format
            'name/cti/camel',
        ],
    });
}

exports.checkAndEvaluateMath = checkAndEvaluateMath;
exports.mapDescriptionToComment = mapDescriptionToComment;
exports.registerTransforms = registerTransforms;
exports.transformColorModifiers = transformColorModifiers;
exports.transformDimension = transformDimension;
exports.transformFontWeights = transformFontWeights;
exports.transformHEXRGBa = transformHEXRGBa;
exports.transformLetterSpacing = transformLetterSpacing;
exports.transformLineHeight = transformLineHeight;
exports.transformShadow = transformShadow;
exports.transformTypographyForCSS = transformTypographyForCSS;
exports.transformTypographyForCompose = transformTypographyForCompose;
